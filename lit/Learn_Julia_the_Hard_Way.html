<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Chris von Csefalvay" />
  <title>Learn Julia the Hard Way</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<div id="header">
<h1 class="title">Learn Julia the Hard Way</h1>
<h2 class="author">Chris von Csefalvay</h2>
</div>
<div id="TOC">
<ul>
<li><a href="#author">Author</a></li>
<li><a href="#with-kind-contributions-from">With kind contributions from</a></li>
<li><a href="#with-thanks-to">With thanks to</a></li>
<li><a href="#license">License</a><ul>
<li><a href="#contributions">Contributions</a></li>
<li><a href="#license-terms">License terms</a></li>
</ul></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#preface">Preface</a></li>
<li><a href="#chapter-0-the-setup">Chapter 0: The Setup</a><ul>
<li><a href="#the-oop-re-education-camp">The OOP Re-Education Camp</a><ul>
<li><a href="#things-to-get-used-to">Things to get used to</a></li>
</ul></li>
<li><a href="#installing-julia">Installing Julia</a><ul>
<li><a href="#binaries">Binaries</a></li>
<li><a href="#package-managers">Package managers</a></li>
<li><a href="#compiling-from-source">Compiling from source</a></li>
</ul></li>
<li><a href="#ijulia">IJulia</a></li>
<li><a href="#colaboratory">CoLaboratory</a><ul>
<li><a href="#juliabox">JuliaBox</a></li>
</ul></li>
<li><a href="#a-word-on-ides">A word on IDEs</a></li>
<li><a href="#ready-teddy">Ready teddy?</a></li>
</ul></li>
<li><a href="#chapter-1-lets-get-printing">Chapter 1: Let’s get printing!</a><ul>
<li><a href="#get-to-know-and-love-the-repl">Get to know and love the REPL</a><ul>
<li><a href="#modes">Modes</a></li>
<li><a href="#key-bindings">Key bindings</a></li>
<li><a href="#autocompletion-and-unicode-entry">Autocompletion and Unicode entry</a></li>
</ul></li>
<li><a href="#lets-say-something">Let’s say something!</a><ul>
<li><a href="#using-the-repl">Using the REPL</a></li>
<li><a href="#using-println">Using <code>println()</code></a></li>
<li><a href="#using-string-concatenation">Using string concatenation</a></li>
</ul></li>
<li><a href="#running-julia-programs">Running Julia programs</a></li>
<li><a href="#chapter-conclusion">Chapter Conclusion</a></li>
</ul></li>
<li><a href="#chapter-2-variables">Chapter 2: Variables</a><ul>
<li><a href="#assigning-variables">Assigning variables</a><ul>
<li><a href="#variable-naming">Variable naming</a></li>
<li><a href="#goodwins-dream">Goodwin’s dream</a></li>
<li><a href="#assigning-variables-to-variables">Assigning variables to variables</a></li>
</ul></li>
<li><a href="#literals">Literals</a><ul>
<li><a href="#strings">Strings</a></li>
<li><a href="#one-dimensional-arrays">One-dimensional arrays</a></li>
<li><a href="#ranges-and-range-arrays">Ranges and range arrays</a></li>
<li><a href="#multidimensional-arrays">Multidimensional arrays</a></li>
<li><a href="#tuples">Tuples</a></li>
<li><a href="#dicts">Dicts</a></li>
<li><a href="#sets">Sets</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></li>
<li><a href="#chapter-3-types">Chapter 3: Types</a><ul>
<li><a href="#julias-type-system">Julia’s type system</a></li>
<li><a href="#declaring-and-testing-types">Declaring and testing types</a><ul>
<li><a href="#declaring-a-subtype">Declaring a (sub)type</a></li>
<li><a href="#asserting-a-type">Asserting a type</a></li>
<li><a href="#specifying-acceptable-function-inputs">Specifying acceptable function inputs</a></li>
</ul></li>
<li><a href="#getting-the-type-of-a-value">Getting the type of a value</a><ul>
<li><a href="#exploring-the-type-hierarchy">Exploring the type hierarchy</a></li>
</ul></li>
<li><a href="#composite-types">Composite types</a><ul>
<li><a href="#creating-your-very-own-immutable">Creating your very own immutable</a></li>
<li><a href="#type-unions">Type unions</a></li>
</ul></li>
<li><a href="#from-start-to-finish-creating-a-custom-type">From start to finish: creating a custom type</a><ul>
<li><a href="#type-definition">Type definition</a></li>
<li><a href="#constructor-function">Constructor function</a></li>
<li><a href="#type-methods">Type methods</a></li>
<li><a href="#representation-of-types">Representation of types</a></li>
<li><a href="#what-next-for-lsd">What next for <code>LSD</code>?</a></li>
</ul></li>
<li><a href="#conclusion-1">Conclusion</a></li>
<li><a href="#appendix-julia-types-crib-sheet">Appendix: Julia types crib sheet</a></li>
</ul></li>
<li><a href="#chapter-4-collections">Chapter 4: Collections</a><ul>
<li><a href="#a-taxonomy-of-collections">A taxonomy of collections</a></li>
<li><a href="#indexable-collections">Indexable collections</a><ul>
<li><a href="#access">Access</a></li>
<li><a href="#common-functions">Common functions</a></li>
<li><a href="#particular-types">Particular types</a></li>
</ul></li>
<li><a href="#associative-collections-dicts">Associative collections: dicts</a><ul>
<li><a href="#creating-dicts">Creating dicts</a></li>
<li><a href="#access-1">Access</a></li>
<li><a href="#sorting-1">Sorting</a></li>
<li><a href="#merging">Merging</a></li>
</ul></li>
<li><a href="#non-indexable-non-associative-collections-sets">Non-indexable non-associative collections: sets</a><ul>
<li><a href="#creating-sets">Creating sets</a></li>
<li><a href="#set-operations">Set operations</a></li>
</ul></li>
<li><a href="#collections-and-types">Collections and types</a><ul>
<li><a href="#type-inference-and-dissimilar-types">Type inference and dissimilar types</a></li>
<li><a href="#type-inference-and-empty-collections">Type inference and empty collections</a></li>
</ul></li>
</ul></li>
<li><a href="#chapter-5-strings">Chapter 5: Strings</a><ul>
<li><a href="#string-and-character-literals">String and character literals</a><ul>
<li><a href="#the-difference-between-string-and-character-literals">The difference between string and character literals</a></li>
<li><a href="#heredocs-and-multiline-literals">Heredocs and multiline literals</a></li>
</ul></li>
<li><a href="#regex-literals">Regex literals</a></li>
<li><a href="#string-operations">String operations</a><ul>
<li><a href="#substrings">Substrings</a></li>
<li><a href="#concatenation-splitting-and-interpolation">Concatenation, splitting and interpolation</a></li>
</ul></li>
<li><a href="#regular-expressions-and-finding-text-within-strings">Regular expressions and finding text within strings</a><ul>
<li><a href="#finding-and-replacing-using-the-search-function">Finding and replacing using the <code>search()</code> function</a></li>
<li><a href="#finding-using-the-match-family-of-functions">Finding using the <code>match()</code> family of functions</a></li>
<li><a href="#replacing-substrings">Replacing substrings</a></li>
<li><a href="#regex-flags">Regex flags</a></li>
</ul></li>
<li><a href="#string-transformation-and-testing">String transformation and testing</a><ul>
<li><a href="#case-transformations">Case transformations</a></li>
<li><a href="#testing-and-attributes">Testing and attributes</a></li>
</ul></li>
<li><a href="#conditions-truth-values-and-comparisons">Conditions, truth values and comparisons</a><ul>
<li><a href="#comparison-operators">Comparison operators</a></li>
<li><a href="#truthiness">Truthiness</a></li>
</ul></li>
<li><a href="#ifelseifelse-and-boolean-switching"><code>if</code>/<code>elseif</code>/<code>else</code>, <code>?</code>/<code>:</code> and boolean switching</a><ul>
<li><a href="#ifelseifelse-syntax"><code>if</code>/<code>elseif</code>/<code>else</code> syntax</a></li>
<li><a href="#ternary-operator">Ternary operator <code>?</code>/<code>:</code></a></li>
<li><a href="#boolean-switching-and">Boolean switching <code>||</code> and <code>&amp;&amp;</code></a></li>
</ul></li>
<li><a href="#while"><code>while</code></a><ul>
<li><a href="#breaking-a-while-loop-break">Breaking a <code>while</code> loop: <code>break</code></a></li>
<li><a href="#skipping-over-results-continue">Skipping over results: <code>continue</code></a></li>
</ul></li>
<li><a href="#for"><code>for</code></a><ul>
<li><a href="#iterating-over-indexable-collections">Iterating over indexable collections</a></li>
<li><a href="#iterating-over-dicts">Iterating over dicts</a></li>
<li><a href="#iteration-over-strings">Iteration over strings</a></li>
</ul></li>
<li><a href="#compound-expressions-beginend-and">Compound expressions: <code>begin</code>/<code>end</code> and <code>;</code></a><ul>
<li><a href="#beginend-blocks"><code>begin</code>/<code>end</code> blocks</a></li>
<li><a href="#syntax"><code>;</code> syntax</a></li>
</ul></li>
</ul></li>
<li><a href="#chapter-7-functions-and-methods">Chapter 7: Functions and methods</a><ul>
<li><a href="#syntax-and-arguments">Syntax and arguments</a><ul>
<li><a href="#general-syntax-and-invocation">General syntax and invocation</a></li>
<li><a href="#variable-numbers-of-positional-arguments-...-splats">Variable numbers of positional arguments: <code>...</code> (‘splats’)</a></li>
<li><a href="#optional-positional-arguments">Optional positional arguments</a></li>
<li><a href="#keyword-arguments">Keyword arguments</a></li>
<li><a href="#stabby-lambda-functions--">Stabby lambda functions: <code>-&gt;</code></a></li>
<li><a href="#do-blocks"><code>do</code> blocks</a></li>
<li><a href="#returning-multiple-values">Returning multiple values</a></li>
<li><a href="#scope-in-function-evaluation">Scope in function evaluation</a></li>
</ul></li>
<li><a href="#higher-order-functions">Higher order functions</a><ul>
<li><a href="#functions-that-accept-functions-as-arguments">Functions that accept functions as arguments</a></li>
<li><a href="#functions-that-return-functions">Functions that return functions</a></li>
<li><a href="#currying">Currying</a></li>
</ul></li>
<li><a href="#methods-and-multiple-dispatch">Methods and multiple dispatch</a><ul>
<li><a href="#understanding-multiple-dispatch">Understanding multiple dispatch</a></li>
<li><a href="#building-methods">Building methods</a></li>
<li><a href="#call-order-and-method-ambiguities">Call order and method ambiguities</a></li>
<li><a href="#parametric-methods">Parametric methods</a></li>
<li><a href="#inspecting-methods">Inspecting methods</a></li>
</ul></li>
</ul></li>
<li><a href="#chapter-8-handling-errors">Chapter 8: Handling errors</a><ul>
<li><a href="#creating-and-raising-exceptions">Creating and raising exceptions</a><ul>
<li><a href="#throwing-exceptions">Throwing exceptions</a></li>
<li><a href="#throwing-a-generic-errorexception">Throwing a generic <code>ErrorException</code></a></li>
<li><a href="#creating-your-own-exceptions">Creating your own exceptions</a></li>
</ul></li>
<li><a href="#handling-exceptions">Handling exceptions</a><ul>
<li><a href="#the-trycatch-structure">The <code>try</code>/<code>catch</code> structure</a></li>
</ul></li>
<li><a href="#advanced-error-handling">Advanced error handling</a><ul>
<li><a href="#info-and-warn"><code>info</code> and <code>warn</code></a></li>
<li><a href="#rethrow-backtrace-and-catch_backtrace"><code>rethrow</code>, <code>backtrace</code> and <code>catch_backtrace</code></a></li>
</ul></li>
<li><a href="#text-files">Text files</a><ul>
<li><a href="#opening-and-closing-files">Opening and closing files</a></li>
<li><a href="#reading-files">Reading files</a></li>
</ul></li>
</ul></li>
<li><a href="#chapter-7-writing-good-julia-functions">Chapter 7: Writing good Julia functions</a><ul>
<li><a href="#performant-code">Performant code</a><ul>
<li><a href="#define-arguments-types-whenever-you-can-and-however-precisely-you-can">Define arguments’ types, whenever you can and however precisely you can</a></li>
<li><a href="#time-your-functions-time-your-changes">Time your functions, time your changes</a></li>
<li><a href="#write-short-concise-functions">Write short, concise functions</a></li>
<li><a href="#danger-zone">Danger zone</a></li>
</ul></li>
<li><a href="#type-stable-code">Type-stable code</a></li>
<li><a href="#legible-code">Legible code</a></li>
</ul></li>
<li><a href="#next-steps">Next steps</a></li>
</ul>
</div>
<h1 id="author">Author</h1>
<p>Chris von Csefalvay</p>
<p><em>The author is the sole and exclusive holder of all commercial rights in and over the entirety of the content. The contributions of all contributors below are acknowledged with the utmost gratitude.</em></p>
<p><em>The contents of this book, where applicable, represent the author’s views or, where appropriate, that of the respective contributor(s). The contents of this book do not necessarily represent the views of any company, organisation or charity that the author is affiliated with.</em></p>
<h1 id="with-kind-contributions-from">With kind contributions from</h1>
<ul>
<li><a href="https://github.com/mschauer">M.Schauer</a></li>
<li><a href="https://github.com/visr">visr</a></li>
<li><a href="https://github.com/brk00">Paulo Roberto de Oliveira Castro</a></li>
<li><a href="https://github.com/MrTomWhite">Tom White</a></li>
<li><a href="http://svaksha.com/pages/Bio">Svaksha</a></li>
<li><a href="http://lugerpitt.blogspot.com/">Louis Luangkesorn</a></li>
</ul>
<h1 id="with-thanks-to">With thanks to</h1>
<ul>
<li>My amazing wife, Katie, who has been nothing but awesome throughout the creation of this manuscript.</li>
<li>Peter Boardman, for his kind permission to use his Wikibook <a href="http://en.wikibooks.org/wiki/Introducing_Julia">Introducing Julia</a> as a foundation for several chapters in this book.</li>
</ul>
<h1 id="license">License</h1>
<p>This material is protected under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International Public License. You may download it and share it with others, as long as you refer back to our CONTRIBUTORS.md file, but you can’t change it in any way or use it commercially.</p>
<h2 id="contributions">Contributions</h2>
<p>Furthermore, by contributing to this project, you grant the Author (Chris von Csefalvay) an irrevocable licence to all content you have contributed. Under this licence, the Author will be entitled to retain the profits of any use of the final document, including your contributions, as long as he provides a general attribution to you. As a contributor, please be aware that one day, the contents of this book may be published. By contributing, you waive any and all rights other than the right to be acknowledged as a contributor to the finished work.</p>
<h2 id="license-terms">License terms</h2>
<p>This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/.</p>
<h1 id="introduction">Introduction</h1>
<h1 id="preface">Preface</h1>
<h1 id="chapter-0-the-setup">Chapter 0: The Setup</h1>
<p>First things first – we’ll have to setup your computer to work with Julia. Fortunately, this is quite easy regardless of the OS you use! Less easy is the mental preparation, namely getting your head around the idea of a functional programming language. Therefore, the first part of this chapter will attempt a brief course in re-educating object-oriented programmers. You should definitely read it if you have been mainly using an object-oriented paradigm. In fact, you should read it anyway.</p>
<h2 id="the-oop-re-education-camp">The OOP Re-Education Camp</h2>
<p>When writing code, we follow some basic concepts about building up a complex structure from simple building blocks. The highest, most abstract level of these concepts is that of programming paradigms. A paradigm can be understood as a very broad guiding idea of writing code.</p>
<p>A <strong>procedural</strong> or <strong>imperative</strong> programming style uses a series of instructions in sequence. This is how most of us have started out programming: one instruction after another. Eventually, it gets more complicated, and subroutines have to get involved to achieve modularity, but ultimately, the idea of procedural programming is to take one step after another, in sequence.</p>
<p><strong>Object-oriented</strong> programming, the currently dominant programming trend, is different. OOP has great reliance on the idea of objects, based on prototypes (often called <em>classes</em>), which are created (<em>instantiated</em>, to use OOP lingo) at a given time. These objects have particular data fields (called <em>attributes</em> or <em>instance variables</em>) and their own bits of code (<em>methods</em>) operating on the instance variables, the object and the world at large. Every object is an instance of a class, that is, it derives its basic form from a pre-defined blueprint. Of course, that’s a very simplistic description of an extremely complex idea, but do bear with me for the moment.</p>
<p><strong>Functional</strong> programming is different. The main point of functional programming is, as the name suggests, to execute functions. In this way, it is very close to mathematics - so close, in fact, that it is based to a great extent on the concept of a <em>lambda calculus</em>, devised by Alonso Church, well before there were computers! Instead of classes, some functional languages, such as Julia, have the concept of <em>types</em>. A <em>type</em> is, quite simply, the kind of structure that a particular bit of information is. For instance, we are all familiar with strings and integers as types, but various other types exist, and there is nothing that keeps you from inventing your own (such as a type representing geographic coordinates).</p>
<p>Functional programming is older than OOP – Lisp, the great big ancestor of all things functional (and many things that are not!), was devised in the 1950s by John McCarthy. However, since then, they have mostly been used in academia to teach computing concepts to first-year undergraduates who can’t wait to progress on to something they can use in the real world. One of the reasons for this was the need to represent changing data. Objects have <em>state</em>, that is, at a given time, their instance variables or attributes have a particular value, which can change depending on what happens in the real world: an object that represents a bank account, for instance, might have a <code>balance</code> attribute that may change if the account holder credits money or withdraws from it. Object-oriented languages are more efficient in representing state and making sure that concurrent transactions affect the object in the right order. Equally, functional languages were seen as less efficient when compared to imperative languages, such as C. This restricted functional languages to a primarily academic role. That is, until it was realised that functional languages can be useful for distributed systems. This spawned a new interest in the new generation of functional languages, such as Haskell, Clojure and Scala. The latter is <a href="http://blog.redfin.com/devblog/2010/05/how_and_why_twitter_uses_scala.html">used by Twitter extensively to manage long-running distributed processes, such as its message queuing and caching layers</a>, while Clojure is used by a number of financial institutions and Big Data intensive users because of the ability to use Java libraries and access Hadoop/HBase easily. Functional programming is no longer a purely academic pursuit.</p>
<p>Julia marries the idea of functional programming to field of statistical or scientific programming. For this reason, much of Julia should come naturally to those more inclined to mathematical thought than the more systemic perspective that OOP people generally have.</p>
<p>As an OOP programmer, you might find yourself at a loss at times. This is normal. Experimenting with a new programming paradigm is always an endeavour that requires some mental restructuring. However, it is worthwhile – not only are multi-paradigm coders generally in higher demand, your OOP code might improve by learning functional tricks as most OOP languages do have some minimal facilities for functional programming strategies. After all, we earn our keep by finding the most appropriate solutions – whether that’s speed, reliability or taking advantage of distributed system power – for the problems we encounter. It can’t ever hurt to have another arrow in our quiver.</p>
<h3 id="things-to-get-used-to">Things to get used to</h3>
<ol style="list-style-type: decimal">
<li>You might be used to things being called as methods, whereas in Julia, they will be called as functions: so e.g. Python’s <code>array.push(x)</code> would correspond to Julia’s <code>push!(array, x)</code>.</li>
<li>Data constructs are expressed through types. These can be as complex as classes, or sometimes even more so!</li>
<li>Not strictly an OOP versus functional thing, but Julia is 1-indexed, not 0-indexed. The _n_th element of an indexable collection has the index <em>n</em>, not <em>n-1</em>.</li>
</ol>
<h2 id="installing-julia">Installing Julia</h2>
<h3 id="binaries">Binaries</h3>
<p>If you use Windows, Mac OS X, Ubuntu, Fedora/RHEL/CentOS or a generic Linux distribution that does packages, the <a href="http://julialang.org/downloads/">download page for the Julia language</a> is the easiest way to obtain an installer or package version of Julia. For the purposes of this book, we will assume you’re using version v0.4. Julia is a young language, and it is developing quite a lot (although the core features have been stable for a pretty long time). There is, currently, no guarantee that the final version – or, indeed, the next version! – will look anything like it currently does.</p>
<h3 id="package-managers">Package managers</h3>
<p>If you’re using a *NIX distribution, you might be able to use your distro’s package manager to get Julia. These are a better option for folks who have hardware or dependency issues while compiling Julia from source. Do remember that if you have installed and update your local copy of Julia via the package manager’s nightly builds, you need to be aware that they run from a different directory than when you compile Julia from source.</p>
<ol style="list-style-type: decimal">
<li><p><strong>Ubuntu</strong>: For Ubuntu users, there is a PPA (Personal Package Archive) provided for Julia. PPA’s are a personal collection of the latest (stable) version of the software not included in Ubuntu by default, packaged and tested by community maintainers and/or upstream developers maintaining the software for the respective Linux distros. So all you need to do is get a shell and run the following commands:</p>
<pre><code>sudo add-apt-repository ppa:staticfloat/juliareleases
sudo add-apt-repository ppa:staticfloat/julia-deps
sudo apt-get update
sudo apt-get install julia</code></pre></li>
<li><p><strong>Fedora</strong>: In Fedora:</p>
<pre><code>sudo dnf copr enable nalimilan/julia
sudo yum install julia</code></pre></li>
<li><p><strong>Arch</strong>: Under Arch Linux, simply install the package, which is available in the ‘community’ repository:</p>
<pre><code>sudo pacman -S julia</code></pre></li>
</ol>
<h3 id="compiling-from-source">Compiling from source</h3>
<p>Julia changes rapidly, with often more than a dozen average changes per day (!) to the source code. Therefore, some people tend to simply pull the most recent nightly build from Git and recompile it every few days. This is a great way to stay ahead of the curve, and also to come across more bugs than one would want to when learning a new language. By all means do use nightly builds when you are confident with Julia, but I do not recommend doing so for the time you are trying to navigate your way through it.</p>
<p>If you do want to use nightly builds (a.k.a PPA’s), simply pull the master branch from the <a href="https://github.com/JuliaLang/julia">Julia GitHub repo</a> and compile by typing make into the Terminal. To speed up the process, you might wish to use a number of concurring processes (<code>make -j n</code>, where <em>n</em> is the number of concurrent processes you are going to use).</p>
<h2 id="ijulia">IJulia</h2>
<p>There is an implementation of the vastly successful IPython notebook environment for Julia. The IPython system, now known as the Jupyter project, is a great way to interactively use Julia in a notebook environment that users of Mathematica or similar software might be used to. It also allows literate coding, mixing Markdown notes and formatting with executable code. To install IJulia, you will need an existing IPython installation, either a distribution like Anaconda or by installing Python and the IPython notebook environment by downloading the Python distribution for your operating system. Once that is in place, install Julia using the instructions above.</p>
<p>To launch Julia, open a Terminal and type <code>julia</code>, which will drop you into the REPL:</p>
<pre><code>$ julia
               _
   _       _ _(_)_     |  A fresh approach to technical computing
  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org
   _ _   _| |_  __ _   |  Type &quot;help()&quot; for help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 0.4.0-dev+2251 (2014-12-23 15:46 UTC)
 _/ |\__&#39;_|_|_|\__&#39;_|  |  master/4814557 (fork: 21 commits, 2 days)
|__/                   |  i686-linux-gnu

julia&gt; </code></pre>
<p>Now, you can install IJulia using the <code>Pkg.add(&quot;IJulia&quot;)</code> command. Congratulations, you now have your very own notebook environment for Julia!</p>
<p>You can fire up the Julia REPL and launch IJulia by:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    using IJulia
    notebook()</code></pre>
<p>Alternatively, to launch your environment, open a new terminal tab to use the profile IPython parameter:</p>
<pre><code>$ ipython notebook --profile julia</code></pre>
<h2 id="colaboratory">CoLaboratory</h2>
<p><a href="https://colaboratory.jupyter.org/welcome/">CoLaboratory</a> is the brainchild of the IPython team. Leveraging the experience and success of IPython, it aims at creating a similar experience, in the cloud, for R and Julia. CoLaboratory is based on Chrome Apps and Google Docs, using the latter as a storage platform. CoLaboratory is a great tool for pair programming and exploring Python, R or Julia together, or for working together on complex projects.</p>
<p>A good introduction to CoLaboratory is <a href="http://heike.github.io/stat590f/ijulia/">this tutorial</a> by Eric Hare and Andee Kaplan. CoLaboratory can be a great alternative to your own local Python installation, especially if scientific programming in the ‘notebook’ context is your thing (migrants from <em>Mathematica</em> are certain to welcome this feature!).</p>
<h3 id="juliabox">JuliaBox</h3>
<p><a href="https://www.juliabox.org/">JuliaBox</a> is a project supported by Julia’s core team, Juliabox allows you to code, store and share your work with other people. However, it is still in <em>beta</em> and mainly used for classroom work by MIT, Stanford and CUNY. Logins are time limited and there are performance limitations. JuliaBox uses a virtual docker instance that it uses to control and execute your work in a segregated environment. If you want to play around with Julia without the need to set up anything on your own computer, JuliaBox is a good alternative. Since notebooks created on JuliaBox are effectively IJulia notebooks, the interface will be quite familiar.</p>
<h2 id="a-word-on-ides">A word on IDEs</h2>
<p>As previously noted, this book diverges from Zed Shaw’s framework a little. As such, I will not take you through the intricacies of setting up an IDE or a text editor. To cut a rather long story short – use what works for you! Fortunately, most text editors do have some form of support for Julia:</p>
<ul>
<li>Vim: <a href="https://github.com/JuliaLang/julia-vim">julia-vim</a></li>
<li>Emacs: Julia highlighting is provided via <a href="http://ess.r-project.org/">Emacs Speaks Statistics</a> (ESS) through <a href="https://github.com/emacs-ess/ESS/wiki/Julia">this</a> package.</li>
<li>Textmate: a <a href="https://github.com/WestleyArgentum/Julia.tmbundle">Julia TextMate Bundle</a> is available, which includes syntax support and somewhat rudimentary bundle features</li>
<li>Sublime Text: <a href="https://github.com/quinnj/Sublime-IJulia">Sublime-IJulia</a> integrates IJulia into Sublime Text - installation is a little complex at this time, but worth it!</li>
<li>Notepad++: <a href="https://gist.github.com/catawbasam/3858496">Syntax highlighting</a> is available for Notepad++.</li>
<li>Light Table: supports Julia out of the box and with more IDE-like features through <a href="http://junolab.org/docs/installing.html">Juno</a>.</li>
</ul>
<h2 id="ready-teddy">Ready teddy?</h2>
<p>Open up Julia by launching IJulia, opening the Julia app provided with the OS X version or calling Julia from the terminal (usually, julia). You are greeted by the Julia REPL.</p>
<pre><code>      _       _ _(_)_     |  A fresh approach to technical computing
     (_)     | (_) (_)    |  Documentation: http://docs.julialang.org
      _ _   _| |_  __ _   |  Type &quot;help()&quot; for help.
     | | | | | | |/ _` |  |
     | | |_| | | | (_| |  |  Version 0.4.0-dev+2214 (2014-12-20 03:45 UTC)
    _/ |\__&#39;_|_|_|\__&#39;_|  |  Commit ddaff3c (4 days old master)
   |__/                   |  x86_64-apple-darwin13.3.0    

julia&gt;</code></pre>
<p>Your version may differ, as will the architecture (final line). If you seek help on Julia forums, always be sure to mention what build you have (the final three lines).</p>
<p>Congratulations. Your adventure begins here.</p>
<h1 id="chapter-1-lets-get-printing">Chapter 1: Let’s get printing!</h1>
<p>In this exercise, we will familiarise ourselves with the Julia REPL and print a few things.</p>
<h2 id="get-to-know-and-love-the-repl">Get to know and love the REPL</h2>
<p>The great thing about REPLs is that they make learning a language a lot easier - especially a language that is at least partly intended to allow you to quickly prototype complex ideas in a few lines of code, manipulate your code, iterate until you get the desired results, then flesh it out or tidy it up.</p>
<p>Using the REPL isn’t complicated, but it might be unusual at first if you have not used much of a similarly constructed REPL (such as Prelude, the Haskell REPL). It helps to remember a few commands and tricks for the future.</p>
<h3 id="modes">Modes</h3>
<p>Julia’s REPL has four ‘modes’, each indicated in the prompt.</p>
<h4 id="julia">Julia</h4>
<p>Prompt: <code>julia&gt;</code></p>
<p>In this mode, you interact with the Julia engine directly. Pressing Return/Enter executes the command in the current line and prints the result. You can also access the result of the last operation in the ans variable. If you don’t wish for Julia to print the result, conclude your line with a ; (semicolon).</p>
<h4 id="help">Help</h4>
<p>Prompt: <code>help&gt;</code></p>
<p>By typing ? at the beginning of a line, you can enter the help mode. Entering anything searches the Julia documentation for that word:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    help?&gt; besselj
    INFO: Loading help data...
    Base.besselj(nu, x)
       Bessel <span class="kw">function</span> of the first kind of order <span class="st">&quot;nu&quot;</span>, J_\nu(x).</code></pre>
<p>To leave help mode, use the Backspace key.</p>
<h4 id="shell">Shell</h4>
<p>Prompt: <code>shell&gt;</code></p>
<p>To execute shell commands, enter <code>;</code>. The REPL prompt will change to <code>shell&gt;</code>, and anything you enter will be executed as a shell command.</p>
<p>To leave shell mode, use the Backspace key.</p>
<h4 id="search">Search</h4>
<p>Prompt: <code>(reverse-i-search)</code></p>
<p>By pressing <code>^R</code> (Ctrl+R), you can initiate a reverse search of your history, including from previous sessions. It will show you any commands that match the pattern you have entered.</p>
<h3 id="key-bindings">Key bindings</h3>
<p>The Julia REPL uses a few key bindings that might be very familiar to those who have used *nix based systems frequently in the past. Most importantly, to exit the REPL, you can use <code>^D</code> (Ctrl+D), which will also close your shell, and you can abort a current operation using <code>^C</code> (Ctrl+C).</p>
<p>There are many more key bindings that the Julia REPL recognises, but these should be enough to get you off the ground.</p>
<h3 id="autocompletion-and-unicode-entry">Autocompletion and Unicode entry</h3>
<p>Julia’s autocomplete feature recognizes the <code>Tab</code> key trigger, your new best friend. Julia also knows Unicode math, so this is valid Julia:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="fl">2</span>*<span class="fl">2.5</span>*π
    <span class="fl">15.707963267948966</span></code></pre>
<p>Pressing the <code>Tab</code> key on a LaTeX symbol name autocompletes to Unicode symbols:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; \sqrt[Tab]<span class="fl">2</span>
    julia&gt; √<span class="fl">2</span>
    <span class="fl">1.4142135623730951</span></code></pre>
<p>For all Unicode completions, check out <a href="https://github.com/JuliaLang/julia/blob/master/doc/manual/unicode-input-table.rst">the Unicode conversion table in the Julia documentation</a>. Remember, you can also use Unicode symbols in saved code.</p>
<h2 id="lets-say-something">Let’s say something!</h2>
<p>In the following, we’ll be exploring a few ways to say hello to Julia. Each of these has their place in the coder’s arsenal, and while you will eventually use the REPL a little less and your text editor a little more, you will probably use the REPL quite a bit to test out new ideas. Think of the REPL as your lab and the text editor as your drawing board – scientists who spend all their time in the lab eventually go mad, while those who are always at the drawing board rarely discover much!</p>
<h3 id="using-the-repl">Using the REPL</h3>
<p>A REPL interface repeats everything you enter. This makes saying hello to the world rather simple – simply declare a variable containing the string literal “Hello, Julia!” or, even simpler, just declare the string literal. Let’s see both of these in action in the REPL.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="st">&quot;Hello, Julia!&quot;</span>
    <span class="st">&quot;Hello, Julia!&quot;</span>

    julia&gt; v = <span class="st">&quot;Hello, Julia!&quot;</span>
    <span class="st">&quot;Hello, Julia!&quot;</span>

    julia&gt; v
    <span class="st">&quot;Hello, Julia!&quot;</span></code></pre>
<h3 id="using-println">Using <code>println()</code></h3>
<p>Now for some actual coding. Time to invoke our first real function. The <code>println</code> function prints the string representation of an object.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; println(<span class="st">&quot;Hello, Julia!&quot;</span>)
    Hello, Julia!</code></pre>
<p>You might notice that the “Hello, Julia!” string is not printed in bold type. This is to indicate that rather than part of the REPL’s print cycle, it is a system output.</p>
<h3 id="using-string-concatenation">Using string concatenation</h3>
<p>String concatenation is just a fancy name for putting strings together. In this case, we create two variables that represent strings, then use the string() function to put them together. The <code>string()</code> function concatenates each of its positional arguments.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; what = <span class="st">&quot;Hello&quot;</span>
    <span class="st">&quot;Hello&quot;</span>

    julia&gt; whom = <span class="st">&quot;Julia&quot;</span>
    <span class="st">&quot;Julia&quot;</span>

    julia&gt; string(what, <span class="st">&quot;, &quot;</span>, whom, <span class="st">&quot;!&quot;</span>)
    <span class="st">&quot;Hello, Julia!&quot;</span></code></pre>
<p>Julia also allows for variables to be called within string literals. So the above is equivalent to:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="st">&quot;$what, $whom\!&quot;</span>
    <span class="st">&quot;Hello, Julia!&quot;</span></code></pre>
<p>And this is true even for maths (or any function!)</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="st">&quot;2 plus 2 is $(2+2).&quot;</span>
    <span class="st">&quot;2 plus 2 is 4.&quot;</span></code></pre>
<h2 id="running-julia-programs">Running Julia programs</h2>
<p>To run a Julia program, you have two options – either include it in another program or the REPL, or specify it as a positional argument in the command line.</p>
<p>Let’s open a file in our favourite text editor, call it <code>hello.jl</code> (the commonly accepted file name for a Julia program), and enter</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    println(<span class="st">&quot;hello world&quot;</span>)</code></pre>
<p>We now have two ways to launch it.</p>
<p>By opening the REPL, we can <code>include</code> the file. This will evaluate everything in the file, then return the result of the last valid expression.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; include(<span class="st">&quot;hello.jl&quot;</span>)
    <span class="st">&quot;Hello, Julia!&quot;</span></code></pre>
<p>Alternatively, you can merely grace your command line with your greeting to Julia by launching Julia with the appropriate argument:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    $ julia hello.jl
    <span class="st">&quot;Hello, Julia!&quot;</span></code></pre>
<h2 id="chapter-conclusion">Chapter Conclusion</h2>
<p>The journey of a thousand miles begins with a single step. If REPLs are something new to you (they are rarely used with a number of OOP languages, and most people using it in Python are using functional(ish) paradigms), then this chapter was two steps at the very least. Give yourself a pat on the back and a cookie, and play around with Julia. See you soon with the next chapter!</p>
<h1 id="chapter-2-variables">Chapter 2: Variables</h1>
<p>We have, of course, encountered variables in the previous chapter, where we used some for string substitution. For a functional programming language, mastery of how variables work is essential. Julia is extremely flexible when it comes to variables, but wielding this flexibility will require finesse.</p>
<h2 id="assigning-variables">Assigning variables</h2>
<p>To assign a variable, simply use <code>=</code> (a single equals sign). That, really, is <em>it</em>. Nice, huh?</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; m = <span class="fl">2.32</span>
    <span class="fl">2.32</span> 
    
    julia&gt; m
    <span class="fl">2.32</span></code></pre>
<p>Accessing an undefined variable yields an exception, of course:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; n
    ERROR: n not defined</code></pre>
<p>Julia does not require you to explicitly declare variables before assignment (indeed, there is no useful way to do so).</p>
<h3 id="variable-naming">Variable naming</h3>
<p>In general, you can use just about anything you can type as a variable name. This includes Unicode characters from a quite astounding range. In case you ever wanted to give your code some Christmas spirit, you are free to do so. In the following, we will be proving, using the comparison operator (<code>&gt;</code>), that winter is not warmer than summer:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; ❄ = -<span class="fl">12</span>
    -<span class="fl">12</span>
    
    julia&gt; ✹ = <span class="fl">27</span>
    <span class="fl">27</span>
    
    julia&gt; ❄ &gt; ✹
    false</code></pre>
<p>The above is, believe it or not, perfectly valid Julia. Whether it is perfectly sensible Julia, too, is a different question. In general, using Unicode variable names for anything but commonly accepted scientific symbols, such as <code>ћ</code>, is not the best idea, lest you might leave readers of your code trying to figure out which of the thirty or so similar looking Unicode symbols you meant.</p>
<p>The stylistic convention of Julia is to use lowercase variable names, with words separated by <code>_</code> (underscore), and only if necessary for the sake of legibility. Variables may not start with numbers and exclamation marks.</p>
<h3 id="goodwins-dream">Goodwin’s dream</h3>
<p>In 1894, an amateur mathematician from Indiana, Edward J. Goodwin, proposed a way to square the circle (a feat proven to be impossible by the Lindeman-Weierstrass theorem proven a decade or so earlier). He lobbied long enough for his ‘new mathematical truth’ to be introduced as a Bill in the Indiana House of Representatives, in what became known as the <em>Indiana Pi Bill</em> of 1897. This inferred a value of approximately 3.2 for π. Fortunately, the intervention of Purdue professor C.A. Waldo helped to defeat the already much-ridiculed bill in the Senate, and the matter was laid to rest.</p>
<p>Julia, on the other hand, allows you to redefine the value of π. The following is entirely correct Julia:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; π
    π = <span class="fl">3.1415926535897</span>...
    
    julia&gt; π = <span class="fl">3.2</span>
    Warning: imported binding <span class="kw">for</span> π overwritten <span class="kw">in</span> <span class="kw">module</span> Main
    <span class="fl">3.2</span>
    
    julia&gt; π
    <span class="fl">3.2</span></code></pre>
<p>It is, on the other hand, really bad practice to redefine set constants. Therefore, should you encounter the opportunity to redefine π, learn from the sad case of Mr. Goodwin and try to resist the temptation.</p>
<h3 id="assigning-variables-to-variables">Assigning variables to variables</h3>
<p>It is important to understand what the effect of assigning a variable to a variable is. It is perfectly valid Julia to have multiple variables point at each other. However, doing so creates a ‘shallow copy’ – that is, a reference to the same memory address of where the original copy is located. If you modify one variable pointing at it, the value of the other changes, too. In the following example, we will be creating an array <code>m</code>, then set <code>n</code> be equal to <code>m</code>. We then carry out an operation that changes the value of <code>m</code>, marked by the exclamation mark (don’t worry if that part is new to you, it will be explained in <a href="https://github.com/chrisvoncsefalvay/learn-julia-the-hard-way/blob/master/_chapters/06-ex3.md">Exercise 3: Collections</a> – for now, all you need to know is that <code>pop!</code> takes the last element of an indexable collection, returns it and removes it from the collection). When we then call <code>n</code>, we see that its value, too, has been affected by the operation – that is because it did not so much have a value but acted merely as a reference to ‘whatever is in m’.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; m = [<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">4</span>]        <span class="co"># Creating array</span>
    <span class="fl">4</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
     <span class="fl">1</span>
     <span class="fl">2</span>
     <span class="fl">3</span>
     <span class="fl">4</span>
     
    julia&gt; n = m                <span class="co"># Setting n to point to m</span>
    <span class="fl">4</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
     <span class="fl">1</span>
     <span class="fl">2</span>
     <span class="fl">3</span>
     <span class="fl">4</span>
     
    julia&gt; pop!(m)              <span class="co"># Altering m</span>
    <span class="fl">4</span>
    
    julia&gt; n                    <span class="co"># n is also changed as a result.</span>
    <span class="fl">3</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
     <span class="fl">1</span>
     <span class="fl">2</span>
     <span class="fl">3</span></code></pre>
<p>We will be considering a way to get around this by ‘deep copying’ a value in chapter [X].</p>
<h2 id="literals">Literals</h2>
<p><em>Literals</em> are ways to enter various data types, whether into the REPL or a program.</p>
<h3 id="strings">Strings</h3>
<p>We have already encountered string literals. To enter a string literal, simply delimit it by <code>&quot;</code> (double quotation marks). Unlike Python or JavaScript, Julia does <strong>not</strong> accept single quotation marks.</p>
<h3 id="one-dimensional-arrays">One-dimensional arrays</h3>
<p>1D array literals are delimited by square brackets (<code>[]</code>). Each element they contain has to be either a variable or an otherwise valid literal, but they do not all have to be the same type (something true for most collections within Julia). Values are separated by a <code>,</code> (comma):</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; arr1 = [<span class="fl">1</span>, <span class="fl">2</span>, <span class="st">&quot;sausage&quot;</span>, π]
    <span class="fl">4</span>-element <span class="dt">Array</span>{<span class="dt">Any</span>,<span class="fl">1</span>}:
         <span class="fl">1</span>
         <span class="fl">2</span>
          <span class="st">&quot;sausage&quot;</span>
         π = <span class="fl">3.1415926535897</span>...</code></pre>
<h3 id="ranges-and-range-arrays">Ranges and range arrays</h3>
<p>A range, in Julia, is simply a shorthand for a sequence of numbers that are all spaced equally. A range can be created using the <code>range()</code> function as <code>range(start, end)</code>, but it is usually denoted in a shorthand literal, <code>start:end</code>. Ranges are interpreted as arrays, and you can create <em>range arrays</em>, arrays that are formed from a range, by simply enclosing the range notation in brackets:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; [<span class="fl">0</span>:<span class="fl">10</span>]
    <span class="fl">11</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
      <span class="fl">0</span>
      <span class="fl">1</span>
      <span class="fl">2</span>
      <span class="fl">3</span>
      <span class="fl">4</span>
      <span class="fl">5</span>
      <span class="fl">6</span>
      <span class="fl">7</span>
      <span class="fl">8</span>
      <span class="fl">9</span>
     <span class="fl">10</span></code></pre>
<p>As you can see, a range in Julia includes both its start and end element. A range doesn’t have to be created between integers – <code>[0.5:3.5]</code> would return an array of <code>[0.5, 1.5, 2.5, 3.5]</code>.</p>
<p>An array may have an optional middle <code>step</code> attribute. To obtain an array of the numbers from 0 to 30 in steps of 10, you would enter the range array literal [0:10:30]:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; [<span class="fl">0</span>:<span class="fl">10</span>:<span class="fl">30</span>]
    <span class="fl">4</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
      <span class="fl">0</span>
     <span class="fl">10</span>
     <span class="fl">20</span>
     <span class="fl">30</span></code></pre>
<h3 id="multidimensional-arrays">Multidimensional arrays</h3>
<p>In some languages, multidimensional arrays can be created by enclosing one-dimensional arrays in another array, and so on. Unfortunately, that is not the case in Julia, so <code>[[1,2],[3,4]]</code> would yield the one-dimensional array <code>[1,2,3,4]</code>. Rather, to create a multidimensional array, separate values by empty space and rows by a <code>;</code> (semicolon):</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; md_array = [<span class="fl">1</span> <span class="fl">1</span> <span class="fl">2</span> <span class="fl">3</span> <span class="fl">5</span>; <span class="fl">8</span> <span class="fl">13</span> <span class="fl">21</span> <span class="fl">34</span> <span class="fl">55</span>; <span class="fl">89</span> <span class="fl">144</span> <span class="fl">233</span> <span class="fl">377</span> <span class="fl">610</span>]
    <span class="fl">3</span>x5 <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">2</span>}:
      <span class="fl">1</span>    <span class="fl">1</span>    <span class="fl">2</span>    <span class="fl">3</span>    <span class="fl">5</span>
      <span class="fl">8</span>   <span class="fl">13</span>   <span class="fl">21</span>   <span class="fl">34</span>   <span class="fl">55</span>
     <span class="fl">89</span>  <span class="fl">144</span>  <span class="fl">233</span>  <span class="fl">377</span>  <span class="fl">610</span></code></pre>
<p>Alternatively, you can enter columns, using square brackets (remember not to let your ingrained reflexes from Python take over and put a comma between the arrays!):</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; [[<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>] [<span class="fl">4</span>,<span class="fl">5</span>,<span class="fl">6</span>]]
    <span class="fl">3</span>x2 <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">2</span>}:
     <span class="fl">1</span>  <span class="fl">4</span>
     <span class="fl">2</span>  <span class="fl">5</span>
     <span class="fl">3</span>  <span class="fl">6</span></code></pre>
<p>When entering a multidimensional array, each row has to have the same length. Failing to do so raises an error:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; md_sparse_array = [<span class="fl">1</span> <span class="fl">1</span> <span class="fl">2</span>; <span class="fl">8</span> <span class="fl">13</span> <span class="fl">21</span> <span class="fl">34</span> <span class="fl">55</span>]
    ERROR: argument count does not match specified shape
     <span class="kw">in</span> hvcat at abstractarray.jl:<span class="fl">802</span></code></pre>
<h3 id="tuples">Tuples</h3>
<p>Tuples are similar to one-dimensional arrays, in that they consist of a number of values. They are, however, unlike array literals in that they are immutable – once assigned, you cannot change the values in a tuple. Tuples are delimited by <code>()</code> (round brackets) and values are separated by commas.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; fibo_tuple = (<span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">5</span>)
    (<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">5</span>)</code></pre>
<p>To demonstrate the difference between arrays and tuples, consider the following:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; fibo_arr = [<span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">5</span>]
    <span class="fl">5</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
     <span class="fl">1</span>
     <span class="fl">1</span>
     <span class="fl">2</span>
     <span class="fl">3</span>
     <span class="fl">5</span>
        
    julia&gt; fibo_arr[<span class="fl">2</span>] = <span class="fl">0</span>
    <span class="fl">0</span>
    
    julia&gt; fibo_arr
    <span class="fl">5</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
     <span class="fl">1</span>
     <span class="fl">0</span>
     <span class="fl">2</span>
     <span class="fl">3</span>
     <span class="fl">5</span>
     
    julia&gt; fibo_tuple[<span class="fl">2</span>] = <span class="fl">0</span>
    ERROR: `setindex!` has no method matching setindex!(::(<span class="dt">Int64</span>,<span class="dt">Int64</span>,<span class="dt">Int64</span>,<span class="dt">Int64</span>,<span class="dt">Int64</span>), ::<span class="dt">Int64</span>, ::<span class="dt">Int64</span>)</code></pre>
<p>In this listing, we have created an array with the first five non-zero elements of the Fibonacci sequence. We then have used an accessor (<code>fibo_arr[2]</code> is an accessor that retrieves the second element of the array <code>fibo_arr</code>) to change the second value in the array to zero. Calling the array shows that this was successful. On the other hand, trying to do the same with the tuple <code>fibo_tuple</code> of the same values that we declared earlier yields an error. This is because tuples are immutable.</p>
<h3 id="dicts">Dicts</h3>
<p>Dicts are what in some other languages are known as <em>associative arrays</em> or <em>maps</em>: they contain key-value pairs. A dict is delimited by square brackets. Individual mappings (key-value pairs) are separated by commas. Keys are separated from values by <code>=&gt;</code> (a double-arrow).</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; statisticians = <span class="dt">Dict</span>(<span class="st">&quot;Gosset&quot;</span> =&gt; <span class="st">&quot;1876-1937&quot;</span>, <span class="st">&quot;Pearson&quot;</span> =&gt; <span class="st">&quot;1857-1936&quot;</span>, <span class="st">&quot;Galton&quot;</span> =&gt; <span class="st">&quot;1822-1911&quot;</span>)
    <span class="dt">Dict</span>{<span class="dt">ASCIIString</span>,<span class="dt">ASCIIString</span>} with <span class="fl">3</span> entries:
      <span class="st">&quot;Galton&quot;</span>  =&gt; <span class="st">&quot;1822-1911&quot;</span>
      <span class="st">&quot;Pearson&quot;</span> =&gt; <span class="st">&quot;1857-1936&quot;</span>
      <span class="st">&quot;Gosset&quot;</span>  =&gt; <span class="st">&quot;1876-1937&quot;</span></code></pre>
<h3 id="sets">Sets</h3>
<p>Sets are similar to other collections in that they contain various values. However, unlike arrays and tuples, they are unordered and unique-constrained: no element may occur multiple times within the set.</p>
<p>Sets do not have a specific notation, but rather are created using a syntax we will use a great deal for creating all kinds of objects: by using the type (<code>Set</code>) and entering the values to constitute the set in round brackets <em>and</em> square braces:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; stooges = <span class="dt">Set</span>([<span class="st">&quot;Moe&quot;</span>, <span class="st">&quot;Curly&quot;</span>, <span class="st">&quot;Larry&quot;</span>])
    <span class="dt">Set</span>(<span class="dt">ASCIIString</span>[<span class="st">&quot;Moe&quot;</span>,<span class="st">&quot;Larry&quot;</span>,<span class="st">&quot;Curly&quot;</span>])</code></pre>
<p>Sets do accept duplicates at time of construction, but the resulting set will still only contain one of each unique element:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; beatles = <span class="dt">Set</span>([<span class="st">&quot;Lennon&quot;</span>, <span class="st">&quot;McCartney&quot;</span>, <span class="st">&quot;Harrison&quot;</span>, <span class="st">&quot;Starr&quot;</span>, <span class="st">&quot;Lennon&quot;</span>])
    <span class="dt">Set</span>(<span class="dt">ASCIIString</span>[<span class="st">&quot;Starr&quot;</span>,<span class="st">&quot;Harrison&quot;</span>,<span class="st">&quot;McCartney&quot;</span>,<span class="st">&quot;Lennon&quot;</span>])</code></pre>
<p>Sets are unordered, meaning that two sets containing the same elements are equal:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="dt">Set</span>([<span class="st">&quot;Marsellus&quot;</span>, <span class="st">&quot;Jules&quot;</span>, <span class="st">&quot;Vincent&quot;</span>]) == <span class="dt">Set</span>([<span class="st">&quot;Jules&quot;</span>, <span class="st">&quot;Vincent&quot;</span>, <span class="st">&quot;Marsellus&quot;</span>])
    true</code></pre>
<p>An empty set is created by</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="dt">Set</span>([])
    <span class="dt">Set</span>{<span class="dt">Any</span>}()</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, we have learned how to construct a handful of literals for the main data types and assign them to variables. This should give us a promising start for our next chapter, in which we are going to explore collections.</p>
<h1 id="chapter-3-types">Chapter 3: Types</h1>
<h2 id="julias-type-system">Julia’s type system</h2>
<p>A type system describes a programming language’s way of handling individual pieces of data and determining how to operate on them based on their type. Julia’s type system is primarily <em>dynamic</em>, meaning that there is no need to tell Julia what type a particular value is. This is useful, in that you can write fairly complex applications without ever needing to specify types. You might, then, be tempted to disregard types as an advanced feature that you cannot be bothered right now. However, a good understanding of types is extremely helpful to mastering a functional language.</p>
<p>Julia’s dynamic system is augmented by the ability to specify types where needed. This has two advantages. First, type specification leads to more efficient code. It will make your code more stable, much faster and much more robust. At the same time, unlike in a statically typed language, you do not need to get your head around types at the very beginning. Thus, you can treat this chapter not so much as a tutorial exercise but as a reference you can come back to every now and then.</p>
<p>It’s important to understand that in Julia, <em>types belong to values, not variables</em>. It’s also important to understand the hierarchy of types in Julia.</p>
<p>Types may be <em>abstract</em> or <em>concrete</em>. You can think of an abstract type as a type that is intended solely to act as supertypes of other types, rather than types of particular objects. Thus, no object that is not a type can have an abstract type as its type.</p>
<p>Concrete types are intended to be the types of actual objects. They are always subtypes of abstract types. This is because concrete types cannot have subtypes, and also because you can’t create types that don’t have supertypes (<code>Any</code> is the default supertype for any type you create). Here is useful to mention an interesting property of Julia’s type system: any two types always have a common ancestor type.</p>
<p>If this feels incredibly convoluted, just bear with it for now. It will make much more sense once you get around to its practical implementations.</p>
<h2 id="declaring-and-testing-types">Declaring and testing types</h2>
<p>Julia’s primary type operator is <code>::</code> (double-colons). It has three different uses, all fairly important, and it’s crucial that you understand the different functions that <code>::</code> fulfills in the different contexts.</p>
<h3 id="declaring-a-subtype">Declaring a (sub)type</h3>
<p>In the context of a <em>statement</em>, such as a function, <code>::</code> appended to a variable means ‘this variable is always to be of this type’. In the following, we will create a function that returns <code>32</code> as <code>Int8</code> (for now, let’s ignore that we don’t know much about functions and we don’t quite know what integer types exist – these will all be explained shortly!).</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="kw">function</span> restrict_this_integer()
            x::<span class="dt">Int8</span> = <span class="fl">32</span>
            x
           <span class="kw">end</span>
    restrict_this_integer (generic <span class="kw">function</span> with <span class="fl">1</span> method)

    julia&gt; p = restrict_this_integer()
    <span class="fl">32</span>

    julia&gt; typeof(p)
    <span class="dt">Int8</span></code></pre>
<p>As we can see, the <code>::</code> within the function had the effect that the returned result would be represented as an 8-bit integer (<code>Int8</code>). Recall that this <em>only works in the context of a statement</em> – thus simply entering <code>x::Int8</code> will yield a <code>typeassert</code> error, telling us that we have provided an integer literal, which Julia understands by default to be an <code>Int64, to be assigned to a variable and shaped as an</code>Int8` – which clearly doesn’t work.</p>
<h3 id="asserting-a-type">Asserting a type</h3>
<p>In every other context, <code>::</code> means ‘I assert this value is of this particular type’. This is a great way to check a value for both abstract and concrete type.</p>
<p>For instance, you are provided a variable <code>input_from_user</code>. How do you make sure it has the right kind of value?</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; input_from_user = <span class="fl">128</span>
    <span class="fl">128</span>

    julia&gt; input_from_user::<span class="dt">Int</span>
    <span class="fl">128</span>

    julia&gt; input_from_user::<span class="dt">Char</span>
    ERROR: <span class="kw">type</span>: typeassert: expected <span class="dt">Char</span>, got <span class="dt">Int64</span></code></pre>
<p>As you can see, if you specify the correct abstract type, you get the value returned, whereas in our second assertion, where we asserted that the value was of the type <code>Char</code> (used to store individual characters), we got a <code>typeassert</code> error, which we can catch later on and return to ensure that we get the right type of value.</p>
<p>Remember that a type hierarchy is like a Venn diagram. Every <code>Int64</code> (a concrete type) is also an <code>Int</code> (an abstract type). Therefore, asserting <code>input_from_user::Int64</code> will also yield <code>128</code>, while asserting a different concrete type, such as <code>Int32</code>, will yield a <code>typeassert</code> error.</p>
<h3 id="specifying-acceptable-function-inputs">Specifying acceptable function inputs</h3>
<p>While we have not really discussed function inputs, you should be familiar with the general idea of a function – values go in, results go out. In Julia, you have the possibility to make sure your function only accepts values that you want it to. Consider creating a function that adds up only floating point numbers:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> addition(x::<span class="dt">Float64</span>, y::<span class="dt">Float64</span>)
        x + y
    <span class="kw">end</span></code></pre>
<p>Calling it on two floating-point numbers will, of course, yield the expected result:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; addition(<span class="fl">3.14</span>, <span class="fl">2.71</span>)
    <span class="fl">5.85</span></code></pre>
<p>But giving it a simpler task will raise an error:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; addition(<span class="fl">1</span>, <span class="fl">1</span>)
    ERROR: `addition` has no method matching addition(::<span class="dt">Int64</span>, ::<span class="dt">Int64</span>)</code></pre>
<p>The real meaning of this error is a little complex, and refers to one of the base features of Julia called <em>multiple dispatch</em>. In Julia, you can create multiple functions with the same name that process different types of inputs, so e.g. an <code>add()</code> function can add up <code>Int</code> and <code>Float</code> inputs but concatenate <code>String</code> type inputs. Multiple dispatch effectively creates a table for every possible type for which the function is defined and looks up the right function at call time (so you can use both abstract and concrete types without a performance penalty). What the error complaining about the lack of a method matching <code>addition(::Int64)</code> means is that Julia cannot find a definition for the name <code>addition</code> that would accept an <code>Int64</code> value.</p>
<h2 id="getting-the-type-of-a-value">Getting the type of a value</h2>
<p>To obtain the type of a value, use the <code>typeof()</code> function:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; typeof(<span class="fl">32</span>)
    <span class="dt">Int64</span></code></pre>
<p><code>typeof()</code> is notable for treating tuples differently from most other collections. Calling <code>typeof()</code> on a tuple enumerates the types of each element, whereas calling it on, say, an <code>Array</code> value returns the <code>Array</code> notation of type (which looks for the largest common type among the values, up to <code>Any</code>):</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; typeof([<span class="fl">1</span>, <span class="fl">2</span>, <span class="st">&quot;a&quot;</span>])
    <span class="dt">Array</span>{<span class="dt">Any</span>,<span class="fl">1</span>}

    julia&gt; typeof((<span class="fl">1</span>, <span class="fl">2</span>, <span class="st">&quot;a&quot;</span>))
    (<span class="dt">Int64</span>,<span class="dt">Int64</span>,<span class="dt">ASCIIString</span>)</code></pre>
<p>Helpfully, the <code>isa()</code> function tells us whether something is a particular type:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; isa(<span class="st">&quot;River&quot;</span>, <span class="dt">ASCIIString</span>)
    true</code></pre>
<p>And, of course, types have types (specifically, <code>DataType</code>)!</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; typeof(<span class="st">&quot;River&quot;</span>)
    <span class="dt">ASCIIString</span> (constructor with <span class="fl">2</span> methods)

    julia&gt; typeof(ans)
    DataType</code></pre>
<h3 id="exploring-the-type-hierarchy">Exploring the type hierarchy</h3>
<p>The <code>&lt;:</code> operator can help you find out whether the left-side type is a subtype of the right-side type. Thus, we see that <code>Int64</code> is a subtype of <code>Int</code>, but <code>ASCIIString</code> isn’t!</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="dt">Int64</span> &lt;: <span class="dt">Int</span>
    true

    julia&gt; <span class="dt">ASCIIString</span> &lt;: <span class="dt">Int</span>
    false</code></pre>
<p>To reveal the supertype of a type, use the <code>super()</code> function:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; super(<span class="dt">ASCIIString</span>)
    DirectIndexString</code></pre>
<h2 id="composite-types">Composite types</h2>
<p>Composite types, known to C coders as <code>structs</code>, are more complex object structures that you can define to hold a set of values. For instance, to have a Type that would accommodate geographic coordinates, you would use a composite type. Composite types are created with the <code>type</code> keyword:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">type</span> GeoCoordinates
        lat::<span class="dt">Float64</span>
        lon::<span class="dt">Float64</span>
    <span class="kw">end</span></code></pre>
<p>We can then create a new value with this type:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; home = GeoCoordinates(<span class="fl">51.7519</span>, <span class="fl">1.2578</span>)
    GeoCoordinates(<span class="fl">51.7519</span>,<span class="fl">1.2578</span>)

    julia&gt; typeof(home)
    GeoCoordinates (constructor with <span class="fl">2</span> methods)</code></pre>
<p>The values of a composite object are, of course, accessible using the dot notation you might be used to from many other programming languages:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; home.lat
    <span class="fl">51.7519</span></code></pre>
<p>In the same way, you can assign new values to it. However, these values have to comply with the type’s definition in that they have to be <em>convertible</em> to the type specified (in our case, <code>Float64</code>). So, for instance, an <code>Int64</code> input would be acceptable, since you can convert an <code>Int64</code> into a <code>Float64</code> easily. On the other hand, an <code>ASCIIString</code> would not do, since you cannot convert it into an <code>Int64</code>.</p>
<h3 id="creating-your-very-own-immutable">Creating your very own immutable</h3>
<p>An <em>immutable</em> type is one which, once instantiated, cannot be changed. They are created the same way as composite types, except by using the <code>immutable</code> keyword in lieu of <code>type</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    immutable GeoCoordinates
        lat::<span class="dt">Float64</span>
        lon::<span class="dt">Float64</span>
    <span class="kw">end</span></code></pre>
<p>Once instantiated, you cannot change the values. So if we would instantiate the immutable <code>GeoCoordinates</code> type with the values above, then attempt to change one of its values, we would get an error:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; home.lat = <span class="fl">51.75</span>
    ERROR: <span class="kw">type</span> GeoCoordinates is immutable</code></pre>
<h3 id="type-unions">Type unions</h3>
<p>Sometimes, it’s useful to have a single alias for multiple types. To do so, you can create a <em>type union</em> using the constructor <code>Union</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; Numeric = <span class="dt">Union</span>(<span class="dt">Int</span>, <span class="dt">Float64</span>)
    <span class="dt">Union</span>(<span class="dt">Float64</span>, <span class="dt">Int64</span>)

    julia&gt; <span class="fl">1</span>::Numeric
    <span class="fl">1</span>

    julia&gt; <span class="fl">3.14</span>::Numeric
    <span class="fl">3.14</span></code></pre>
<h2 id="from-start-to-finish-creating-a-custom-type">From start to finish: creating a custom type</h2>
<p>When you hear LSD, you might be tempted of the groovy drug that turned the ’70s weird. It also refers to one of the biggest problems of early computing in Britain – making computers make sense of Britain’s odd pre-decimal currency system before it was abandoned in 1971. Under this system, there were 20 shillings (<code>s</code>) in a pound (<code>£</code> or <code>L</code>) and twelve pence (<code>d</code>) in a shilling (so, 240 pence in a pound). This made electronic book-keeping in its earliest era in Britain rather difficult. Let’s see how Julia would solve the problem.</p>
<h3 id="type-definition">Type definition</h3>
<p>First of all, we need a type <em>definition</em>. We also know that this would be a <em>composite</em> type, since we want it to hold three values (known in this context as ‘fields’) - one for each of pounds, shillings and pence. We also know that these would have to be integers.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">type</span> LSD
        pounds::<span class="dt">Int</span>
        shillings::<span class="dt">Int</span>
        pence::<span class="dt">Int</span>
    <span class="kw">end</span></code></pre>
<p>You don’t strictly need to define types, but the narrower the types you define for fields when you create a new type, the faster compilation is going to be - thus, <code>pounds::Int</code> is faster than <code>pounds</code>, and <code>pounds::Int64</code> is faster than <code>pounds::Int</code>. At any rate, avoid not defining any data types, which Julia will understand as referring to the global supertype <code>::Any</code>, unless that indeed is what you want your field to embrace.</p>
<h3 id="constructor-function">Constructor function</h3>
<p>We have a good start, but not quite there yet. Every type can have a <em>constructor function</em>, the function executed when a new instance of a type is created. A constructor function is <em>inside the type definition</em> and <em>has the same name as the type</em>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> LSD(l,s,d)
        <span class="kw">if</span> l &lt; <span class="fl">0</span> || s &lt; <span class="fl">0</span> || d &lt; <span class="fl">0</span>
            error(<span class="st">&quot;No negative numbers, please! We&#39;re British!&quot;</span>)
        <span class="kw">end</span>
        <span class="kw">if</span> d &gt; <span class="fl">12</span> || s &gt; <span class="fl">20</span>
            error(<span class="st">&quot;That&#39;s too many pence or shillings!&quot;</span>)
        <span class="kw">end</span>
        new(l,s,d)
    <span class="kw">end</span></code></pre>
<p>Don’t worry if this looks a little strange – since we haven’t dealt with functions yet, most of this is going to be alien to you. What the function <code>LSD(l,s,d)</code> does is to, first, test whether any of <code>l</code>, <code>s</code> or <code>d</code> are negative or whether there are more pence or shillings than there could be in a shilling or a pound, respectively. In both of these cases, it raises an error. If the values do comply, it creates the new instance of the <code>LSD</code> composite type using the <code>new(l,s,d)</code> keyword.</p>
<p>The full type definition, therefore, would look like this:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">type</span> LSD
        pounds::<span class="dt">Int</span>
        shillings::<span class="dt">Int</span>
        pence::<span class="dt">Int</span>

        <span class="kw">function</span> LSD(l,s,d)
            <span class="kw">if</span> l &lt; <span class="fl">0</span> || s &lt; <span class="fl">0</span> || d &lt; <span class="fl">0</span>
                error(<span class="st">&quot;No negative numbers, please! We&#39;re British!&quot;</span>)
            <span class="kw">end</span>
            <span class="kw">if</span> d &gt; <span class="fl">12</span> || s &gt; <span class="fl">20</span>
                error(<span class="st">&quot;That&#39;s too many pence or shillings!&quot;</span>)
            <span class="kw">end</span>
            new(l,s,d)
        <span class="kw">end</span>
    <span class="kw">end</span></code></pre>
<p>As we can see, we can now create valid prices in the old LSD system:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; biscuits = LSD(<span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">3</span>)
    LSD(<span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">3</span>)</code></pre>
<p>And the constructor function makes sure we don’t contravene the constraints we set up earlier</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; sausages = LSD(<span class="fl">1</span>,<span class="fl">25</span>,<span class="fl">31</span>)
    ERROR: That&#39;s too many pence or shillings!
     <span class="kw">in</span> LSD at none:<span class="fl">11</span>

    julia&gt; national_debt = LSD(-<span class="fl">1000000000</span>,<span class="fl">0</span>,<span class="fl">0</span>)
    ERROR: No negative numbers, please! We&#39;re British!
     <span class="kw">in</span> LSD at none:<span class="fl">8</span></code></pre>
<p>We can, of course, use dot notation to access constituent values of the type, the names of which derive from the beginning of our definition:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; biscuits.pence
    <span class="fl">3</span></code></pre>
<h3 id="type-methods">Type methods</h3>
<p>Let’s see how our new type deals with some simple maths:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; biscuits = LSD(<span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">3</span>)
    LSD(<span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">3</span>)

    julia&gt; gravy = LSD(<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">5</span>)
    LSD(<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">5</span>)

    julia&gt; biscuits + gravy
    ERROR: `+` has no method matching +(::LSD, ::LSD)</code></pre>
<p>Ooops, that’s not great. What the error message means is that the function <code>+</code> (addition) has no ‘method’ for two instances of type <code>LSD</code> (as you remember, <code>::</code> is short for ‘type of’). A ‘method’, in Julia, is a type-specific way for an operation or function to behave. As we will discuss it in detail later on, most functions and operators in Julia are actually shorthands for a bundle of multiple methods. Julia decides which of these to call given the input, a feature known as <em>multiple dispatch</em>. So, for instance, <code>+</code> given the input <code>::Int</code> means numerical addition, but something rather different for two Boolean values:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; true + true
    <span class="fl">2</span></code></pre>
<p>In fact, <code>+</code> is the ‘shorthand’ for over a hundred methods. You can see all of these by calling <code>methods()</code> on <code>+</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; methods(+)
    <span class="co"># 117 methods for generic function &quot;+&quot;:</span>
    +(x::<span class="dt">Bool</span>) at bool.jl:<span class="fl">36</span>
    +(x::<span class="dt">Bool</span>,y::<span class="dt">Bool</span>) at bool.jl:<span class="fl">39</span>
    +(y::FloatingPoint,x::<span class="dt">Bool</span>) at bool.jl:<span class="fl">49</span>
    +(A::BitArray{N},B::BitArray{N}) at bitarray.jl:<span class="fl">848</span></code></pre>
<p>…and so on. What we need is there to be a method that accommodates the type <code>LSD</code>. We do that by creating a method of <code>+</code> for the type <code>LSD</code>. Again, the function is less important here (it will be trivial after reading the chapter on <em>Functions</em>), what matters is the idea of creating a method to augment an existing function/operator to handle our new type:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">     julia&gt; <span class="kw">function</span> +{LSD}(a::LSD, b::LSD)
              newpence = a.pence + b.pence
              newshillings = a.shillings + b.shillings
              newpounds = a.pounds + b.pounds
              subtotal = newpence + newshillings * <span class="fl">12</span> + newpounds * <span class="fl">240</span>
              (pounds, balance) = divrem(subtotal, <span class="fl">240</span>)
              (shillings, pence) = divrem(balance, <span class="fl">12</span>)
              LSD(pounds, shillings, pence)
            <span class="kw">end</span></code></pre>
<p>When entering it in the REPL, Julia tells us that <code>+</code> now has one more method:</p>
<pre><code>+ (generic function with 118 methods)</code></pre>
<p>Indeed, <code>methods(+)</code> shows that the new method for two <code>LSD</code>s is registered:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; methods(+)
    <span class="co"># 118 methods for generic function &quot;+&quot;:</span>
    +(x::<span class="dt">Bool</span>) at bool.jl:<span class="fl">36</span>
    +(x::<span class="dt">Bool</span>,y::<span class="dt">Bool</span>) at bool.jl:<span class="fl">39</span>
    ...
    +{LSD}(a::LSD,b::LSD) at none:<span class="fl">2</span></code></pre>
<p>And now we know the price of biscuits and gravy:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; biscuits + gravy
    LSD(<span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">8</span>)</code></pre>
<h3 id="representation-of-types">Representation of types</h3>
<p>Every type has a particular ‘representation’, which is what we encountered every time the REPL showed us the value of an object after entering an expression or a literal. It probably won’t surprise you that representations are methods of the <code>Base.show()</code> function, and a new method to ‘pretty-print’ our <code>LSD</code> type (similar to creating a <code>__repr__</code> or <code>__str__</code> function in a Python class’s declaration) can be created the same way:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> Base.show(io::<span class="dt">IO</span>, money::LSD)
        print(io, <span class="st">&quot;£$(money.pounds), $(money.shillings)s, $(money.pence)d.&quot;</span>)
    <span class="kw">end</span></code></pre>
<p><code>Base.show</code> has two arguments: the output channel, which we do not need to concern ourselves with, and the second argument, which is the value to be displayed. We declared a function that used the <code>print()</code> function to use the output channel on which <code>Base.show()</code> is called, and display the second argument, which is a string formatted version of the <code>LSD</code> object.</p>
<p>Our pretty-printing worked:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; biscuits + gravy
    £<span class="fl">0</span>, <span class="fl">1</span>s, <span class="fl">8</span>d.</code></pre>
<p>Our new type is looking quite good!</p>
<h3 id="what-next-for-lsd">What next for <code>LSD</code>?</h3>
<p>Of course, the <code>LSD</code> type is far from ready. We need to define a list of other methods, from subtraction to division, but the general concept ought to be clear. A new type is easy to create, but when doing so, you as a developer need to keep in mind what you and your users will do with this new type, and create methods accordingly. Chapter [X] will discuss methods in depth, but this introduction should help you think intelligently about creating new types.</p>
<h2 id="conclusion-1">Conclusion</h2>
<p>In this chapter, we learned about the way Julia’s type system is set up. The issue of types will be at the background of most of what we do in the future, so feel free to refer back to this chapter as frequently as you feel the need to. In the next chapter, we will be exploring collections, a category of types that share one important property – they all act as ‘envelopes’ for multiple elements, each with their distinct type.</p>
<h2 id="appendix-julia-types-crib-sheet">Appendix: Julia types crib sheet</h2>
<p>This is a selection of Julia’s type tree, omitting quite a few elements. To see the full thing, you can use Tanmay Mohapatra’s <a href="https://github.com/tanmaykm/julia_types"><code>julia_types.jl</code></a>.</p>
<p><TODO: Insert nicely formatted crib sheet here & dendrogram version for print edition></p>
<h1 id="chapter-4-collections">Chapter 4: Collections</h1>
<h2 id="a-taxonomy-of-collections">A taxonomy of collections</h2>
<p>We have already encountered some collections in the previous chapter – arrays, tuples, dicts and sets. This chapter examines what we can do with collections and how to best use them for maximum effectiveness. A collection may be <em>indexable</em>, <em>associative</em> or neither. This refers primarily to the way we access individual elements within the collection.</p>
<p>Think of an <em>indexable</em> collection as a shopping list – the only way to identify individual elements is by pointing out their position. If you want to refer to, say, <em>1 pint of milk</em>, you refer to it as <em>the fifth entry on my shopping list</em>. Elements of an indexable collection are accessed using the square bracket notation <code>collection[index]</code>, e.g. <code>shopping_list[5]</code>. Unusually for most programming languages and in sharp contrast to other languages like Python, indices begin with 1, rather than 0. An indexable collection is also only equal to a collection with the same elements if they are in the same order – thus <code>[1, 3, 5, 7] == [3, 7, 1, 5]</code> yields, as one would expect, <code>false</code>.</p>
<p><em>Associative</em> collections, on the other hand, resemble a page from a phone book instead (if any of you actually still remember what one of those things is!). You wouldn’t say that your phone number is on page 217, left column, fifth from the bottom. Rather, you would have a <em>key</em> (your name), by reference to which someone can find your phone number (the <em>value</em>). Associative arrays do follow the key-value pair form. They are, therefore, not accessed in the <code>collection[index]</code> form but rather in the <code>collection[key]</code> form. An associative collection is not indexable, therefore the order of entries does not matter: two associative collections will be equal as long as they contain the same key-value pairs, order regardless.</p>
<p>Collections that are neither associative nor indexable are a somewhat complex case. Sets are the only frequently used collection that is netiher associative nor indexable. They are also special because of the uniqueness constraint, that is, a set may contain each value once and only once. A set does not support the commonly used methods of access, but it does support many of the collection manipulation functions, such as <code>push!()</code> and <code>pop!()</code>. The latter, in case you were wondering, returns items in a random order, since the absence of an index means sets are not ordered. Sets are not indexable, consequently two sets that contain the same elements will be considered equal, order regardless.</p>
<p>In addition, collections may be <em>mutable</em> or <em>non-mutable</em>. Put quite simply, a mutable collection is one where you can change particular values after creation, while in an immutable collection, you cannot do so. The typical immutable collections are, of course, tuples – once you have assigned a value to a tuple, you cannot change that value (although you can assign some other tuple or indeed an entirely different value to the variable that holds the tuple). Sets again represent a special case – they are what could be best described as <em>pseudo-immutable</em> – there is no way to access values in a way that could change them, since you normally access an element of a set by its value (which is sufficient in a set thanks to the uniqueness constraint).</p>
<table>
<thead>
<tr class="header">
<th align="center"></th>
<th align="center"><strong>Mutable</strong></th>
<th align="center"><strong>Immutable</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><strong>Indexable</strong></td>
<td align="center">Arrays</td>
<td align="center">Tuples</td>
</tr>
<tr class="even">
<td align="center"><strong>Associative</strong></td>
<td align="center">Dicts</td>
<td align="center"></td>
</tr>
<tr class="odd">
<td align="center"><strong>Non-indexable and non-associative</strong></td>
<td align="center"></td>
<td align="center">Sets</td>
</tr>
</tbody>
</table>
<h2 id="indexable-collections">Indexable collections</h2>
<h3 id="access">Access</h3>
<p>Elements of an indexable collection can be accessed using the square bracket notation, by their ordinal:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; prime_array = [<span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">5</span>, <span class="fl">7</span>, <span class="fl">11</span>]
    <span class="fl">5</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
      <span class="fl">2</span>
      <span class="fl">3</span>
      <span class="fl">5</span>
      <span class="fl">7</span>
     <span class="fl">11</span>

    julia&gt; prime_array[<span class="fl">3</span>]
    <span class="fl">5</span></code></pre>
<p>In Julia, a range of numbers is written as <code>start:end</code> or <code>start:steps:end</code>. You can use a range to access a range of elements:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; prime_array[<span class="fl">2</span>:<span class="fl">3</span>]
    <span class="fl">2</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
     <span class="fl">3</span>
     <span class="fl">5</span></code></pre>
<p>A range always returns a collection, even if it has the length 1. This is exemplified by the difference between <code>prime_array[3]</code>, the call we made above, and <code>prime_array[3:3]</code>, which returns</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; prime_array[<span class="fl">3</span>:<span class="fl">3</span>]
    <span class="fl">1</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
     <span class="fl">5</span>

    julia&gt; prime_array[<span class="fl">3</span>:<span class="fl">3</span>] == <span class="fl">5</span>
    false</code></pre>
<p>You can access the last element of an indexable collection using <code>[end]</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; prime_array[<span class="kw">end</span>]
     <span class="fl">11</span></code></pre>
<p>Incidentally, <code>end</code> behaves like a number – so <code>prime_array[end-1]</code> returns the penultimate element of the collection.</p>
<h4 id="setting">Setting</h4>
<p>If the indexable collection you are using is also mutable (e.g. an array), any of these methods will act as a pseudo-variable and will allow you to assign a value to it. Thus <code>prime_array[end] = 12</code> would change the last element of <code>prime_array</code> to 12. You also aren’t restricted to a single element: calling <code>prime_array[2:4] = 0</code> would result in</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; prime_array
    <span class="fl">5</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
      <span class="fl">2</span>
      <span class="fl">0</span>
      <span class="fl">0</span>
      <span class="fl">0</span>
     <span class="fl">11</span></code></pre>
<p>And, of course, you can use an array or another indexable collection to replace values:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; prime_array[<span class="fl">2</span>:<span class="fl">4</span>] = [<span class="fl">3</span>,<span class="fl">5</span>,<span class="fl">7</span>]
    <span class="fl">3</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
     <span class="fl">3</span>
     <span class="fl">5</span>
     <span class="fl">7</span>
     
    julia&gt; prime_array
    <span class="fl">5</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
      <span class="fl">2</span>
      <span class="fl">3</span>
      <span class="fl">5</span>
      <span class="fl">7</span>
     <span class="fl">11</span></code></pre>
<h4 id="unpacking">Unpacking</h4>
<p>Indexable collections can <em>unpack</em>: that is, they can be assigned in a single line to as many distinct variables as they have elements. This is a very useful convenience feature, and is much used in functional programming:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; actors = [<span class="st">&quot;Ian McKellen&quot;</span>, <span class="st">&quot;Martin Freeman&quot;</span>, <span class="st">&quot;Elijah Wood&quot;</span>]
    <span class="fl">3</span>-element <span class="dt">Array</span>{<span class="dt">ASCIIString</span>,<span class="fl">1</span>}:
     <span class="st">&quot;Ian McKellen&quot;</span>
     <span class="st">&quot;Martin Freeman&quot;</span>
     <span class="st">&quot;Elijah Wood&quot;</span>

    julia&gt; gandalf, bilbo, frodo = actors
    <span class="fl">3</span>-element <span class="dt">Array</span>{<span class="dt">ASCIIString</span>,<span class="fl">1</span>}:
     <span class="st">&quot;Ian McKellen&quot;</span>
     <span class="st">&quot;Martin Freeman&quot;</span>
     <span class="st">&quot;Elijah Wood&quot;</span>

    julia&gt; gandalf
    <span class="st">&quot;Ian McKellen&quot;</span></code></pre>
<p>Unpacking can also be used to swap the contents of variables:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; firstname = <span class="st">&quot;Irving&quot;</span>
    julia&gt; lastname = <span class="st">&quot;Washington&quot;</span>

    julia&gt; firstname, lastname = lastname, firstname
    (<span class="st">&quot;Washington&quot;</span>,<span class="st">&quot;Irving&quot;</span>)

    julia&gt; lastname
    <span class="st">&quot;Irving&quot;</span></code></pre>
<h3 id="common-functions">Common functions</h3>
<h4 id="push-pop-and-append"><code>push!</code>, <code>pop!</code> and <code>append!</code></h4>
<p><code>push!</code> appends the value to the end of the collection. <code>pop!</code> takes the last element of the list, returns it and removes it from the collection.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; array = [<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">4</span>]
    <span class="fl">4</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
     <span class="fl">1</span>
     <span class="fl">2</span>
     <span class="fl">3</span>
     <span class="fl">4</span>

    julia&gt; push!(array, <span class="fl">5</span>)
    <span class="fl">5</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
     <span class="fl">1</span>
     <span class="fl">2</span>
     <span class="fl">3</span>
     <span class="fl">4</span>
     <span class="fl">5</span>

    julia&gt; pop!(array)
    <span class="fl">5</span>

    julia&gt; array
    <span class="fl">4</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
     <span class="fl">1</span>
     <span class="fl">2</span>
     <span class="fl">3</span>
     <span class="fl">4</span></code></pre>
<p><code>append!</code>, somewhat unusually, puts the elements of a collection to the end of another collection:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; array2 = [<span class="fl">5</span>,<span class="fl">6</span>,<span class="fl">7</span>]
    <span class="fl">3</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
     <span class="fl">5</span>
     <span class="fl">6</span>
     <span class="fl">7</span>

    julia&gt; append!(array, array2)
    <span class="fl">7</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
     <span class="fl">1</span>
     <span class="fl">2</span>
     <span class="fl">3</span>
     <span class="fl">4</span>
     <span class="fl">5</span>
     <span class="fl">6</span>
     <span class="fl">7</span></code></pre>
<h4 id="shift-and-unshift"><code>shift!</code> and <code>unshift!</code></h4>
<p><code>shift!</code> ans <code>unshift!</code> are the front equivalent of <code>pop!</code> and <code>push!</code>. Similarly to <code>pop!</code>, <code>shift!</code> retrieves the first element of the collection and removes it from the collection (which <em>shifts</em> it):</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; shift!(array)
    <span class="fl">1</span></code></pre>
<p>Similarly to <code>push!</code>, <code>unshift!</code> puts an element to the front of the collection:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; unshift!(array, <span class="fl">8</span>)
    <span class="fl">7</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
     <span class="fl">8</span>
     <span class="fl">2</span>
     <span class="fl">3</span>
     <span class="fl">4</span>
     <span class="fl">5</span>
     <span class="fl">6</span>
     <span class="fl">7</span></code></pre>
<h4 id="find-functions"><code>find</code> functions</h4>
<p>There’s a set of functions starting with find — such as <code>find()</code>, <code>findfirst()</code>, and <code>findnext()</code> — that you can use to get the index or indices of values within an indexable collection that match a specific value, or pass a test. These functions share three properties.</p>
<ol style="list-style-type: decimal">
<li>Their result is the <em>index or indices of the value sought or tested for</em>, with the _n_th element’s index being <em>n</em>, not <em>n-1</em> as you might be used to from other languages.</li>
<li>You can use these functions in two principal forms: you can test for a value or you can test for a function, in which case the results will be the values for which the function returns <code>true</code>.</li>
<li>The <code>find</code> functions’ way of telling you they haven’t found anything is returning zero, since there is no element of index zero.</li>
</ol>
<p>Let’s try to find things within the following <code>Array</code>: <code>primes_and_one = [1,2,3,5,7,11,13,17,19,23]</code></p>
<h5 id="findfirst"><code>findfirst()</code></h5>
<p><code>findfirst()</code> finds the first occurrence of a value and returns its index (or zero):</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; findfirst(primes_and_one, <span class="fl">5</span>)
    <span class="fl">4</span></code></pre>
<p>As noted above, we can feed the <code>find</code> functions a function as well – it will return values for which the function would return a <code>true</code> value. We have not really discussed functions, but the general idea should be familiar to you. A function of the form <code>x -&gt; x == 13</code> results in <code>true</code> of the value of <code>x</code> is 13 and <code>false</code> otherwise. Let’s try to see which prime number is the first to equal 13 (don’t expect big surprises):</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; findfirst(x -&gt; x == <span class="fl">13</span>, primes_and_one)
    <span class="fl">7</span></code></pre>
<p>You might have noticed that unlike in the case where you were searching for a particular value, <em>where you’re searching by a function, the function comes first</em>. This is a little idiosyncrasy, but has to do with the way Julia determines what to do based on what it is provided with. A lot more of this will be explored in Chapter [X].</p>
<h5 id="find"><code>find()</code></h5>
<p><code>find()</code> returns an array of results. Thus, for instance, let’s use the <code>isinteger</code> function to see which of our primes are integers (yet again, the result should not come as a shock):</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; find(isinteger, primes_and_one)
    <span class="fl">10</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
      <span class="fl">1</span>
      <span class="fl">2</span>
      <span class="fl">3</span>
      <span class="fl">4</span>
      <span class="fl">5</span>
      <span class="fl">6</span>
      <span class="fl">7</span>
      <span class="fl">8</span>
      <span class="fl">9</span>
     <span class="fl">10</span></code></pre>
<h5 id="findnext"><code>findnext()</code></h5>
<p><code>findnext()</code> returns results from a given index onwards. Thus, if you want to know the index of the first odd number after 3 in the list of primes, you would proceed as follows (using the function <code>isodd</code>, which, as you could guess, returns <code>true</code> for odd integers and <code>false</code> otherwise):</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; findnext(isodd, primes_and_one, <span class="fl">4</span>)
    <span class="fl">4</span></code></pre>
<p>Wait, why <code>4</code>? As you might remember, Julia is 1-indexed, not 0-indexed. Therefore, an index ‘begins before’ the number. The number after the first index is the first number in the sequence and so on. As such, the number after the third item in a collection is the item next to (= following) the index <code>4</code>, not <code>3</code>.</p>
<p>As you might have noticed, when you use a function as an argument, you do not use the parentheses you would normally use to call a function. That is because <code>function()</code> means <code>call this function</code> while <code>function</code> is merely a reference to the function object itself.</p>
<h5 id="get-elements-not-indices">Get elements, not indices</h5>
<p>So far, we’ve only been getting indices. How do we get the actual elements? The answer is, of course, by using our magical <code>[]</code>(square brackets) syntax. We’ll also use this as a good opportunity to introduce a very useful function, <code>isprime()</code>, which returns <code>true</code> for primes and false otherwise:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; find(isprime, primes_and_one)
    <span class="fl">9</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
      <span class="fl">2</span>
      <span class="fl">3</span>
      <span class="fl">4</span>
      <span class="fl">5</span>
      <span class="fl">6</span>
      <span class="fl">7</span>
      <span class="fl">8</span>
      <span class="fl">9</span>
     <span class="fl">10</span>
     
    julia&gt; primes_and_one[find(isprime,primes_and_one)]
    <span class="fl">9</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
      <span class="fl">2</span>
      <span class="fl">3</span>
      <span class="fl">5</span>
      <span class="fl">7</span>
     <span class="fl">11</span>
     <span class="fl">13</span>
     <span class="fl">17</span>
     <span class="fl">19</span>
     <span class="fl">23</span></code></pre>
<h4 id="filtering">Filtering</h4>
<p>The <code>filter()</code> function works quite similar to <code>find</code>, except in this case returns only the elements that satisfy the condition (it is, effectively, a shorthand for the previous listing).</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; filter(isodd, primes_and_one)
    <span class="fl">9</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
      <span class="fl">1</span>
      <span class="fl">3</span>
      <span class="fl">5</span>
      <span class="fl">7</span>
     <span class="fl">11</span>
     <span class="fl">13</span>
     <span class="fl">17</span>
     <span class="fl">19</span>
     <span class="fl">23</span></code></pre>
<p><code>filter()</code> can be used in-place, by using the <code>!</code> after the name of the function. Thus, using <code>filter!()</code>, alters the actual array rather than returning a filtered copy. Note, however, that functions ending with <code>!</code> modify the object, so, obviously, the type they act on must be mutable – you would, therefore, not be able to <code>filter!()</code> a tuple, even though you would be able to <code>filter()</code> it.</p>
<h4 id="sorting">Sorting</h4>
<p>The <code>sort()</code> function sorts an array lexicographically, generally in an ascending order:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; sort([-<span class="fl">3</span>, <span class="fl">2</span>, <span class="fl">1</span>, <span class="fl">7</span>])
    <span class="fl">4</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
     -<span class="fl">3</span>
     <span class="fl">1</span>
     <span class="fl">2</span>
     <span class="fl">7</span></code></pre>
<p>You can specify the sort criterion using <code>by</code> – in this case, we will be using the absolute value function <code>abs</code> (remember not to use the parentheses symbolising function call, just the name of the function):</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; sort([-<span class="fl">3</span>,<span class="fl">2</span>,<span class="fl">1</span>,<span class="fl">7</span>], by=abs)
    <span class="fl">4</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
      <span class="fl">1</span>
      <span class="fl">2</span>
     -<span class="fl">3</span>
      <span class="fl">7</span></code></pre>
<p>You can change the order of sorting using <code>rev</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; sort([-<span class="fl">3</span>,<span class="fl">2</span>,<span class="fl">1</span>,<span class="fl">7</span>], by=abs, rev=true)
    <span class="fl">4</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
      <span class="fl">7</span>
     -<span class="fl">3</span>
      <span class="fl">2</span>
      <span class="fl">1</span></code></pre>
<p>And, for the great joy of algorithm nerds like me, you can choose the sort algorithm using <code>alg</code>. Julia currently supports three sorting algorithms (<code>InsertionSort</code>, <code>QuickSort</code> and <code>MergeSort</code>).</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; sort([-<span class="fl">3</span>,<span class="fl">2</span>,<span class="fl">1</span>,<span class="fl">7</span>], by=abs, rev=true, alg=MergeSort)
    <span class="fl">4</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
      <span class="fl">7</span>
     -<span class="fl">3</span>
      <span class="fl">2</span>
      <span class="fl">1</span></code></pre>
<p>For mutable indexable collections, such as arrays, you can use <code>sort!()</code>, which sorts ‘in place’. Of course, you can also sort non-numeric elements, or indeed anything for which the <code>isless()</code> function is defined, which sorting uses internally.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; sort([<span class="st">&quot;Bayes&quot;</span>, <span class="st">&quot;Laplace&quot;</span>, <span class="st">&quot;Poisson&quot;</span>, <span class="st">&quot;Gauss&quot;</span>])
    <span class="fl">4</span>-element <span class="dt">Array</span>{<span class="dt">ASCIIString</span>,<span class="fl">1</span>}:
     <span class="st">&quot;Bayes&quot;</span>
     <span class="st">&quot;Gauss&quot;</span>
     <span class="st">&quot;Laplace&quot;</span>
     <span class="st">&quot;Poisson&quot;</span></code></pre>
<h4 id="counting">Counting</h4>
<p><code>count()</code> tells you the number of instances in the collection that satisfy the criterion:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; count(isodd, primes_and_one)
    <span class="fl">9</span></code></pre>
<h4 id="all-and-any"><code>all()</code> and <code>any()</code></h4>
<p><code>all()</code> and <code>any()</code> implement two of the mathematical concepts known as <em>quantifiers</em>, with <code>all()</code> representing the universal quantifier <code>\forall</code>, while <code>any()</code> implements the existential quantifier. These functions test whether all or any, respectively, of a collection satisfies a certain criterion, and return a single truth value.</p>
<h4 id="existence-of-a-particular-value">Existence of a particular value</h4>
<p>To find out whether an array has a particular value among its elements, you can use <code>in()</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="kw">in</span>(<span class="fl">2</span>, primes)
    true</code></pre>
<p>Somewhat strangely, in the <code>in()</code> syntax, the needle comes before the haystack, i.e. <code>in(value, array)</code>, where <code>value</code> denotes the value you are looking for.</p>
<h3 id="particular-types">Particular types</h3>
<h4 id="arrays">Arrays</h4>
<p>Arrays (the ones we used in our examples so far in this section) are mutable indexable collections. The type <code>Array{T,N}</code> indicates an <code>N</code>-dimensional array which elements’ types are subtypes of <code>T</code>. For instance, <code>Array{Number, 2}</code> is an 2-dimensional array. Its elements’ types descend from <code>Number</code> (e.g.<code>Int</code>, <code>Float64</code>).</p>
<h5 id="access-in-multidimensional-arrays">Access in multidimensional arrays</h5>
<p>How do we access elements in a multidimensional array, a special form of indexable collection? Simple – in a multidimensional array, indexes go down each row, then from left to right. Therefore, this array</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; md_array = [<span class="st">&quot;A&quot;</span> <span class="st">&quot;B&quot;</span>; <span class="st">&quot;C&quot;</span> <span class="st">&quot;D&quot;</span>]
    <span class="fl">2</span>x2 <span class="dt">Array</span>{<span class="dt">ASCIIString</span>,<span class="fl">2</span>}:
     <span class="st">&quot;A&quot;</span>  <span class="st">&quot;B&quot;</span>
     <span class="st">&quot;C&quot;</span>  <span class="st">&quot;D&quot;</span></code></pre>
<p>would be indexed as follows:</p>
<pre><code>md_array[1] = &quot;A&quot;
md_array[2] = &quot;C&quot;
md_array[3] = &quot;B&quot;
md_array[4] = &quot;D&quot;</code></pre>
<p>This is a little counterintuitive and different from the usual row/column notation, where you would use <code>array[row][column]</code>. To retrieve a cell by row and column, use <code>array[row, column]</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; md_array[<span class="fl">1</span>,<span class="fl">2</span>]
    <span class="st">&quot;B&quot;</span></code></pre>
<p>This generalizes for higher dimension arrays.</p>
<h4 id="tuples-1">Tuples</h4>
<p>A tuple is an ordered sequence of elements, like an array. A tuple is represented by parentheses and commas, rather than the square brackets used by arrays. The important difference between arrays and tuples is that <em>tuples are immutable</em>: you can’t change the elements of a tuple, or the tuple itself, after creating it.</p>
<p>Tuples are generally used for small fixed-length collections — they’re ubiquitous across Julia, for example as argument lists. Where a function returns multiple values, which, as we see, is pretty often the case, the result is a tuple.</p>
<p>A corollary of immutability is that none of the <code>!</code> functions work on tuples - but at the same time, using functions such as <code>push()</code> is perfectly acceptable, since it returns <em>a copy of the tuple with the added element</em>, which does not alter the original tuple.</p>
<h2 id="associative-collections-dicts">Associative collections: dicts</h2>
<p>An associative collection is a kind of non-indexed collection that stores (usually) pairs of values. The indexable collections you have encountered correspond to real-life examples such as a shopping list or a sequential list of train stations. Associative collections, on the other hand, have a <em>key</em> and a <em>value</em> (for this reason, they are sometimes referred to as <em>key-value pairs</em>). Julia, like many other programming languages, implements associative collections in an object called a <code>dict</code> (short for <code>dictionary</code>), which corresponds to ‘maps’, ‘hash tables’ or ‘dictionaries’ in other programming languages.</p>
<p>A dict, as we have seen, is usually created using the dict literal</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    dict = <span class="dt">Dict</span>(<span class="st">&quot;a&quot;</span> =&gt; <span class="fl">1</span>, <span class="st">&quot;b&quot;</span> =&gt; <span class="fl">2</span>, <span class="st">&quot;c&quot;</span> =&gt; <span class="fl">3</span>)</code></pre>
<p>The key of a key-value pair is <em>unique</em>, meaning that while several keys might point at the same value (and a key might point at a collection as a value), you cannot have duplicate keys (in database terminology, you might have heard this referred to as a <em>one-to-many relationship</em>).</p>
<h3 id="creating-dicts">Creating dicts</h3>
<p>Other than the <code>Dict()</code> literal, there are three more ways to create a dict.</p>
<p>First, you can create a dict using the <em>comprehension syntax</em> for dicts. An example is</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    [i =&gt; sqrt(i) <span class="kw">for</span> i = <span class="fl">1</span>:<span class="fl">2</span>:<span class="fl">15</span>]</code></pre>
<p>This creates a dict with the square root of every odd number from 1 to 15. In this case, <code>i</code> can be any iterable – while ranges are the most frequently used, there is no reason why</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="dt">Dict</span>(i =&gt; sqrt(i) <span class="kw">for</span> i = [<span class="fl">2</span>, <span class="fl">5</span>, <span class="fl">6</span>, <span class="fl">8</span>, <span class="fl">12</span>, <span class="fl">64</span>])</code></pre>
<p>would not be equally valid.</p>
<p>Secondly, you can also create an empty dictionary. <code>Dict()</code> will construct an empty dictionary that permits any elements, while <code>Dict{type1, type2}()</code> will create an empty dictionary that permits any elements with keys of <code>type1</code> and values of <code>type2</code>.</p>
<p>Finally, earlier versions of Julia used to support what is sometimes referred to as <em>zip creation</em> of a dict, namely entering two equal-length tuples, one for keys and one for values. This is now regarded as deprecated – it still works, but you should not use it. Instead, the correct syntax is <code>Dict(zip(ks, vs))</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    ks = (<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)
    vs = (<span class="st">&quot;1&quot;</span>, <span class="st">&quot;2&quot;</span>, <span class="st">&quot;3&quot;</span>)
    
    julia&gt; <span class="dt">Dict</span>(zip(ks,vs))
    <span class="dt">Dict</span>{<span class="dt">ASCIIString</span>,<span class="dt">ASCIIString</span>} with <span class="fl">3</span> entries:
      <span class="st">&quot;c&quot;</span> =&gt; <span class="st">&quot;3&quot;</span>
      <span class="st">&quot;b&quot;</span> =&gt; <span class="st">&quot;2&quot;</span>
      <span class="st">&quot;a&quot;</span> =&gt; <span class="st">&quot;1&quot;</span></code></pre>
<h3 id="access-1">Access</h3>
<p>Just like items in an indexable arrays are keyed by their index, items in a dict are identified by their key and retrieved using the square bracket syntax:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; statisticians = <span class="dt">Dict</span>(<span class="st">&quot;Gosset&quot;</span> =&gt; <span class="st">&quot;1876-1937&quot;</span>, <span class="st">&quot;Pearson&quot;</span> =&gt; <span class="st">&quot;1857-1936&quot;</span>, <span class="st">&quot;Galton&quot;</span> =&gt; <span class="st">&quot;1822-1911&quot;</span>)
    <span class="dt">Dict</span>{<span class="dt">ASCIIString</span>,<span class="dt">ASCIIString</span>} with <span class="fl">3</span> entries:
      <span class="st">&quot;Galton&quot;</span>  =&gt; <span class="st">&quot;1822-1911&quot;</span>
      <span class="st">&quot;Pearson&quot;</span> =&gt; <span class="st">&quot;1857-1936&quot;</span>
      <span class="st">&quot;Gosset&quot;</span>  =&gt; <span class="st">&quot;1876-1937&quot;</span>
      
    julia&gt; statisticians[<span class="st">&quot;Gosset&quot;</span>]
    <span class="st">&quot;1876-1937&quot;</span></code></pre>
<p>One drawback of the bracket syntax is that if there is no entry for the key provided, Julia will raise an error:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; statisticians[<span class="st">&quot;Kendall&quot;</span>]
    ERROR: key not found: <span class="st">&quot;Kendall&quot;</span>
     <span class="kw">in</span> getindex at dict.jl:<span class="fl">644</span></code></pre>
<p>An alternative form of accessing a dictionary is using the <code>get()</code> function, which accepts a default value:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; get(statisticians, <span class="st">&quot;Pearson&quot;</span>, <span class="st">&quot;I&#39;m sorry, I don&#39;t know when this person lived.&quot;</span>)
    <span class="st">&quot;1857-1936&quot;</span>
    
    julia&gt; get(statisticians, <span class="st">&quot;Kendall&quot;</span>, <span class="st">&quot;I&#39;m sorry, I don&#39;t know when this person lived.&quot;</span>)
    <span class="st">&quot;I&#39;m sorry, I don&#39;t know when this person lived.&quot;</span></code></pre>
<p>An advantage of this is that you can create a default value, which the function will return if it cannot find the key requested. Unlike in some other programming languages, a default is <em>not optional</em> for Julia:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; get(statisticians, <span class="st">&quot;Kendall&quot;</span>)
    ERROR: `get` has no method matching get(::<span class="dt">Dict</span>{<span class="dt">ASCIIString</span>,<span class="dt">ASCIIString</span>}, ::<span class="dt">ASCIIString</span>)</code></pre>
<h4 id="get-or-create-get">Get or create (<code>get!()</code>)</h4>
<p>Because dicts are mutable, <code>get!()</code> can try to access a value by its key and create it if not found, then return the new value. Its syntax is identical to <code>get()</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; get!(statisticians, <span class="st">&quot;Kendall&quot;</span>, <span class="st">&quot;I&#39;m sorry, I don&#39;t know when this person lived.&quot;</span>)
    <span class="st">&quot;I&#39;m sorry, I don&#39;t know when this person lived.&quot;</span>
    
    julia&gt; statisticians
    <span class="dt">Dict</span>{<span class="dt">ASCIIString</span>,<span class="dt">ASCIIString</span>} with <span class="fl">4</span> entries:
      <span class="st">&quot;Galton&quot;</span>  =&gt; <span class="st">&quot;1822-1911&quot;</span>
      <span class="st">&quot;Pearson&quot;</span> =&gt; <span class="st">&quot;1857-1936&quot;</span>
      <span class="st">&quot;Kendall&quot;</span> =&gt; <span class="st">&quot;I&#39;m sorry, I don&#39;t know when this person lived.&quot;</span>
      <span class="st">&quot;Gosset&quot;</span>  =&gt; <span class="st">&quot;1876-1937&quot;</span></code></pre>
<h4 id="pop"><code>pop!()</code></h4>
<p><code>pop!()</code> returns the key-value array matching the key. If the key does not exist, it returns an optional default value or throws an error:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; pop!(statisticians, <span class="st">&quot;Gosset&quot;</span>)
    <span class="st">&quot;1876-1937&quot;</span>
    
    julia&gt; statisticians
    <span class="dt">Dict</span>{<span class="dt">ASCIIString</span>,<span class="dt">ASCIIString</span>} with <span class="fl">3</span> entries:
      <span class="st">&quot;Galton&quot;</span>  =&gt; <span class="st">&quot;1822-1911&quot;</span>
      <span class="st">&quot;Pearson&quot;</span> =&gt; <span class="st">&quot;1857-1936&quot;</span>
      <span class="st">&quot;Kendall&quot;</span> =&gt; <span class="st">&quot;1907-1983&quot;</span></code></pre>
<h4 id="change-values">Change values</h4>
<p>To change a value, access it via the bracket syntax, then assign it the new value:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; statisticians[<span class="st">&quot;Kendall&quot;</span>] = <span class="st">&quot;1907-1983&quot;</span>
    <span class="st">&quot;1907-1983&quot;</span>
    
    julia&gt; statisticians
    <span class="dt">Dict</span>{<span class="dt">ASCIIString</span>,<span class="dt">ASCIIString</span>} with <span class="fl">4</span> entries:
      <span class="st">&quot;Galton&quot;</span>  =&gt; <span class="st">&quot;1822-1911&quot;</span>
      <span class="st">&quot;Pearson&quot;</span> =&gt; <span class="st">&quot;1857-1936&quot;</span>
      <span class="st">&quot;Kendall&quot;</span> =&gt; <span class="st">&quot;1907-1983&quot;</span>
      <span class="st">&quot;Gosset&quot;</span>  =&gt; <span class="st">&quot;1876-1937&quot;</span></code></pre>
<h4 id="checking-for-existence-of-a-key-or-a-key-value-pair">Checking for existence of a key or a key-value pair</h4>
<p>To check for the existence of a key without retrieving it, you can use <code>haskey()</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; haskey(statisticians, <span class="st">&quot;Galton&quot;</span>)
    true
    
    julia&gt; haskey(statisticians, <span class="st">&quot;Bayes&quot;</span>)
    false</code></pre>
<p>You can also check for the existence of a key-value pair in a dict using the <code>in()</code> function you might be familiar with from arrays. Note that the notation of a key-value pair in this case will be in the form of a tuple <code>(key, value)</code> rather than using the associative array symbol <code>=&gt;</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="kw">in</span>((<span class="st">&quot;Bayes&quot;</span>, <span class="st">&quot;1702-1761&quot;</span>), statisticians)
    false</code></pre>
<h4 id="retrieving-keys-or-values">Retrieving keys or values</h4>
<p>To retrieve all keys of a dict, use <code>keys()</code>. This will retrieve an object of type <code>KeyIterator</code>, which does just what the name suggests - it iterates through the keys of an array. This will be useful later on when we want to iterate through the dictionary by keys:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; keys(statisticians)
    KeyIterator <span class="kw">for</span> a <span class="dt">Dict</span>{<span class="dt">ASCIIString</span>,<span class="dt">ASCIIString</span>} with <span class="fl">3</span> entries. Keys:
      <span class="st">&quot;Galton&quot;</span>
      <span class="st">&quot;Pearson&quot;</span>
      <span class="st">&quot;Kendall&quot;</span></code></pre>
<p>You can retrieve values, predictably, by using the <code>values()</code> function:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; values(statisticians)
    ValueIterator <span class="kw">for</span> a <span class="dt">Dict</span>{<span class="dt">ASCIIString</span>,<span class="dt">ASCIIString</span>} with <span class="fl">3</span> entries. Values:
      <span class="st">&quot;1822-1911&quot;</span>
      <span class="st">&quot;1857-1936&quot;</span>
      <span class="st">&quot;1907-1983&quot;</span></code></pre>
<h3 id="sorting-1">Sorting</h3>
<p>You may have noticed that dicts are unordered. Even a dict generated by reference to a range, such as the one seen above, will not be in any particular order:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; [i =&gt; sqrt(i) <span class="kw">for</span> i = <span class="fl">1</span>:<span class="fl">2</span>:<span class="fl">15</span>]
    <span class="dt">Dict</span>{<span class="dt">Int64</span>,<span class="dt">Float64</span>} with <span class="fl">8</span> entries:
      <span class="fl">7</span>  =&gt; <span class="fl">2.6457513110645907</span>
      <span class="fl">9</span>  =&gt; <span class="fl">3.0</span>
      <span class="fl">13</span> =&gt; <span class="fl">3.605551275463989</span>
      <span class="fl">3</span>  =&gt; <span class="fl">1.7320508075688772</span>
      <span class="fl">11</span> =&gt; <span class="fl">3.3166247903554</span>
      <span class="fl">5</span>  =&gt; <span class="fl">2.23606797749979</span>
      <span class="fl">15</span> =&gt; <span class="fl">3.872983346207417</span>
      <span class="fl">1</span>  =&gt; <span class="fl">1.0</span></code></pre>
<p>This is because dicts are not indexable, therefore there is no ordering that would make inherent sense. However, sometimes, we like dictionaries sorted. Disappointingly, sorting dicts is not as easy as sorting arrays: <code>sort(statisticians)</code> tells us that <code>'sort' has no method matching sort(::Dict{ASCIIString,ASCIIString})</code>. Therefore, you have to write your own sort function that first converts <code>statisticians</code> from a dict into an array of 2-element tuples. This is because the <code>sort()</code> function has no defined methods for dicts, but it can sort arrays, including tuples, where it sorts by the first element in the tuple. Then, it iterates through the result and represents it as a dict again:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    result = <span class="dt">Dict</span>{<span class="dt">ASCIIString</span>, <span class="dt">ASCIIString</span>}
    <span class="kw">for</span> (k,v) <span class="kw">in</span> sort(collect(statisticians))
        result[k] =&gt; v
        println(result)
    <span class="kw">end</span></code></pre>
<p>This yields the expected result:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    Galton =&gt; <span class="fl">1822</span>-<span class="fl">1911</span>
    Kendall =&gt; <span class="fl">1907</span>-<span class="fl">1983</span>
    Pearson =&gt; <span class="fl">1857</span>-<span class="fl">1936</span></code></pre>
<p>If you want the output to be in-place or yield an actual dict, you will have to augment your code a little:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    result = <span class="dt">Dict</span>()
    <span class="kw">for</span> (k::<span class="dt">ASCIIString</span>,v::<span class="dt">ASCIIString</span>) <span class="kw">in</span> sort(collect(statisticians))
        setindex!(result, v, k)
    <span class="kw">end</span>
           
    julia&gt; result
    <span class="dt">Dict</span>{<span class="dt">Any</span>,<span class="dt">Any</span>} with <span class="fl">3</span> entries:
      <span class="st">&quot;Galton&quot;</span>  =&gt; <span class="st">&quot;1822-1911&quot;</span>
      <span class="st">&quot;Pearson&quot;</span> =&gt; <span class="st">&quot;1857-1936&quot;</span>
      <span class="st">&quot;Kendall&quot;</span> =&gt; <span class="st">&quot;1907-1983&quot;</span></code></pre>
<h3 id="merging">Merging</h3>
<p>The function <code>merge()</code> merges two or more dicts.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; mathematicians = <span class="dt">Dict</span>(<span class="st">&quot;Gauss&quot;</span> =&gt; <span class="st">&quot;1777-1855&quot;</span>, <span class="st">&quot;Leibniz&quot;</span> =&gt; <span class="st">&quot;1646-1716&quot;</span>, <span class="st">&quot;Abel&quot;</span> =&gt; <span class="st">&quot;1802-1829&quot;</span>)
    <span class="dt">Dict</span>{<span class="dt">ASCIIString</span>,<span class="dt">ASCIIString</span>} with <span class="fl">3</span> entries:
      <span class="st">&quot;Abel&quot;</span>    =&gt; <span class="st">&quot;1802-1829&quot;</span>
      <span class="st">&quot;Leibniz&quot;</span> =&gt; <span class="st">&quot;1646-1716&quot;</span>
      <span class="st">&quot;Gauss&quot;</span>   =&gt; <span class="st">&quot;1777-1855&quot;</span>
      
    julia&gt; merge(mathematicians, statisticians)
    <span class="dt">Dict</span>{<span class="dt">ASCIIString</span>,<span class="dt">ASCIIString</span>} with <span class="fl">6</span> entries:
      <span class="st">&quot;Abel&quot;</span>    =&gt; <span class="st">&quot;1802-1829&quot;</span>
      <span class="st">&quot;Galton&quot;</span>  =&gt; <span class="st">&quot;1822-1911&quot;</span>
      <span class="st">&quot;Leibniz&quot;</span> =&gt; <span class="st">&quot;1646-1716&quot;</span>
      <span class="st">&quot;Gauss&quot;</span>   =&gt; <span class="st">&quot;1777-1855&quot;</span>
      <span class="st">&quot;Pearson&quot;</span> =&gt; <span class="st">&quot;1857-1936&quot;</span>
      <span class="st">&quot;Kendall&quot;</span> =&gt; <span class="st">&quot;1907-1983&quot;</span></code></pre>
<p>Its bang counterpart, <code>merge!()</code>, merges them in place, overwriting the first dict mentioned while leaving the second intact.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; merge!(mathematicians, statisticians)
    <span class="dt">Dict</span>{<span class="dt">ASCIIString</span>,<span class="dt">ASCIIString</span>} with <span class="fl">6</span> entries:
      <span class="st">&quot;Abel&quot;</span>    =&gt; <span class="st">&quot;1802-1829&quot;</span>
      <span class="st">&quot;Galton&quot;</span>  =&gt; <span class="st">&quot;1822-1911&quot;</span>
      <span class="st">&quot;Leibniz&quot;</span> =&gt; <span class="st">&quot;1646-1716&quot;</span>
      <span class="st">&quot;Gauss&quot;</span>   =&gt; <span class="st">&quot;1777-1855&quot;</span>
      <span class="st">&quot;Pearson&quot;</span> =&gt; <span class="st">&quot;1857-1936&quot;</span>
      <span class="st">&quot;Kendall&quot;</span> =&gt; <span class="st">&quot;1907-1983&quot;</span>
      
    julia&gt; mathematicians
    <span class="dt">Dict</span>{<span class="dt">ASCIIString</span>,<span class="dt">ASCIIString</span>} with <span class="fl">6</span> entries:
      <span class="st">&quot;Abel&quot;</span>    =&gt; <span class="st">&quot;1802-1829&quot;</span>
      <span class="st">&quot;Galton&quot;</span>  =&gt; <span class="st">&quot;1822-1911&quot;</span>
      <span class="st">&quot;Leibniz&quot;</span> =&gt; <span class="st">&quot;1646-1716&quot;</span>
      <span class="st">&quot;Gauss&quot;</span>   =&gt; <span class="st">&quot;1777-1855&quot;</span>
      <span class="st">&quot;Pearson&quot;</span> =&gt; <span class="st">&quot;1857-1936&quot;</span>
      <span class="st">&quot;Kendall&quot;</span> =&gt; <span class="st">&quot;1907-1983&quot;</span>
      
    julia&gt; statisticians
      <span class="dt">Dict</span>{<span class="dt">ASCIIString</span>,<span class="dt">ASCIIString</span>} with <span class="fl">3</span> entries:
      <span class="st">&quot;Galton&quot;</span>  =&gt; <span class="st">&quot;1822-1911&quot;</span>
      <span class="st">&quot;Pearson&quot;</span> =&gt; <span class="st">&quot;1857-1936&quot;</span>
      <span class="st">&quot;Kendall&quot;</span> =&gt; <span class="st">&quot;1907-1983&quot;</span></code></pre>
<h2 id="non-indexable-non-associative-collections-sets">Non-indexable non-associative collections: sets</h2>
<p>You might be familiar with the idea of sets from maths/set theory. A set is a non-indexable, non-associative and non-mutable collection that also has unique elements. No element may occur twice, so an element’s value identifies it conclusively.</p>
<h3 id="creating-sets">Creating sets</h3>
<p>To create a set, use the <code>Set()</code> constructor function. You can create a set that accepts any data type</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; primes = <span class="dt">Set</span>()
    <span class="dt">Set</span>{<span class="dt">Any</span>}({})</code></pre>
<p>– or you can specify what sort of data types it would accept:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; primes = <span class="dt">Set</span>{<span class="dt">Int64</span>}()
    <span class="dt">Set</span>{<span class="dt">Int64</span>}({})</code></pre>
<p>You can create and fill sets in one go by listing elements surrounded by curly braces <code>{}</code>, and if you surround the elements with square brackets <code>[]</code> instead of curly braces <code>{}</code> Julia will guess the type:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; mersenne_primes_set = <span class="dt">Set</span>([<span class="fl">3</span>, <span class="fl">7</span>, <span class="fl">31</span>, <span class="fl">127</span>])
    <span class="dt">Set</span>([<span class="fl">7</span>,<span class="fl">31</span>,<span class="fl">3</span>,<span class="fl">127</span>])</code></pre>
<h3 id="set-operations">Set operations</h3>
<p>Sets have some unique functions that accommodate certain problems well-known from set theory: the functions <code>union()</code>, <code>intersect()</code> and <code>setdiff()</code> each, respectively, implement the union, intersection and difference of sets. Let’s see how we can use this to find some similarities between the cast of two blockbusters, <em>The Lord of the Rings</em> and <em>The Matrix</em>.</p>
<p>First, let’s create two sets with some actors from each movie:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    lotr_actors = <span class="dt">Set</span>([<span class="st">&quot;Elijah Wood&quot;</span>, <span class="st">&quot;Ian McKellen&quot;</span>, <span class="st">&quot;Viggo Mortensen&quot;</span>, <span class="st">&quot;Hugo Weaving&quot;</span>])
    matrix_actors = <span class="dt">Set</span>([<span class="st">&quot;Keanu Reeves&quot;</span>, <span class="st">&quot;Lawrence Fishburne&quot;</span>, <span class="st">&quot;Hugo Weaving&quot;</span>]</code></pre>
<p>To find shared actors, we can use <code>intersect()</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; intersect(lotr_actors, matrix_actors)
    <span class="dt">Set</span>(<span class="dt">ASCIIString</span>[<span class="st">&quot;Hugo Weaving&quot;</span>])</code></pre>
<p>To find actors who only starred in <em>Lord of the Rings</em> but not in <em>The Matrix</em>, we can use <code>setdiff()</code>, which shows all elements that are in the first <code>Set</code> but not the second:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">     julia&gt; setdiff(lotr_actors, matrix_actors)
     <span class="dt">Set</span>(<span class="dt">ASCIIString</span>[<span class="st">&quot;Elijah Wood&quot;</span>,<span class="st">&quot;Ian McKellen&quot;</span>,<span class="st">&quot;Viggo Mortensen&quot;</span>])</code></pre>
<p>Finally, we can see actors who played in either of the movies, by using <code>union()</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; union(lotr_actors, matrix_actors)
    <span class="dt">Set</span>(<span class="dt">ASCIIString</span>[<span class="st">&quot;Elijah Wood&quot;</span>,<span class="st">&quot;Ian McKellen&quot;</span>,<span class="st">&quot;Hugo Weaving&quot;</span>,<span class="st">&quot;Keanu Reeves&quot;</span>,<span class="st">&quot;Lawrence Fishburne&quot;</span>,<span class="st">&quot;Viggo Mortensen&quot;</span>])</code></pre>
<h2 id="collections-and-types">Collections and types</h2>
<p>Until now, we have generally created collections using literals, and with precious little regard to the types of information that go in them. While types will be discussed in quite a bit of detail later on, what we do know about types is that they are individual categories of data.</p>
<p>Julia operates what is called <em>type inference</em>: unless you tell it explicitly what type something is, it tries to figure it out best as it can. We see this in operation when we create a new collection. When a collection is created and Julia is not told that this is going to be a collection containing elements of only a particular kind or particular kinds of values, it makes an educated guess. The REPL tells us this much:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; mersenne_primes = [<span class="fl">3</span>, <span class="fl">7</span>, <span class="fl">31</span>, <span class="fl">127</span>, <span class="fl">8191</span>, <span class="fl">131071</span>]
    <span class="fl">6</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
          <span class="fl">3</span>
          <span class="fl">7</span>
         <span class="fl">31</span>
        <span class="fl">127</span>
       <span class="fl">8191</span>
     <span class="fl">131071</span></code></pre>
<p>Upon creating the array, the REPL reports to us that it’s an array consisting of six elements, all of type <code>Int64</code> – a type of signed 64-bit integer (don’t worry if that means quite little to you just yet, we will be discussing various integer types in Chapter [X]). It also, helpfully, reports to us that we’ve got a 1-dimensional array.</p>
<h3 id="type-inference-and-dissimilar-types">Type inference and dissimilar types</h3>
<p>What, however, if I want to play it a little wild and mix it up? Consider the following array:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">     julia&gt; not_really_mersenne_primes = [<span class="fl">3</span>, <span class="fl">7</span>, <span class="st">&quot;potato&quot;</span>, <span class="fl">127</span>, π, <span class="st">&quot;wallaby&quot;</span>]
     <span class="fl">6</span>-element <span class="dt">Array</span>{<span class="dt">Any</span>,<span class="fl">1</span>}:
          <span class="fl">3</span>
          <span class="fl">7</span>
           <span class="st">&quot;potato&quot;</span>
          <span class="fl">127</span>
          π = <span class="fl">3.1415926535897</span>...
          <span class="st">&quot;wallaby&quot;</span></code></pre>
<p>As you have guessed, Julia is at a loss as to what to do with this, since we’ve got a mix of integers, strings and a constant thrown in for good measure. Therefore, it tells us that it has inferred the type of the collection to be <code>Any</code> – a type that applies to all objects.</p>
<h3 id="type-inference-and-empty-collections">Type inference and empty collections</h3>
<p>The other marginal case is that of the empty set. Julia has a dedicated type, <code>None</code> – a subtype of <code>Any</code> – that applies to the empty set:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; empty_set = []
    <span class="fl">0</span>-element <span class="dt">Array</span>{<span class="dt">None</span>,<span class="fl">1</span>}</code></pre>
<h1 id="chapter-5-strings">Chapter 5: Strings</h1>
<p>A string is a sequence of one or more characters, and one of the most frequently used types in programming. It is therefore fitting that we acquaint ourselves with the idea of operating on strings.</p>
<h2 id="string-and-character-literals">String and character literals</h2>
<p>You might be familiar by now with string and character literals from the introductory chapter, which introduced some literals, or from other programming languages. A string literal is surrounded by <em>double quotes</em>: <code>&quot; string &quot;</code>. Within the string, you can escape a double-quote using a backslash:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="st">&quot;This string contains a </span>\&quot;<span class="st"> double quote </span>\&quot;<span class="st"> &quot;</span></code></pre>
<p>Strings are <em>immutable</em> and <em>indexable</em> – indices return the characters at the index position, starting from 1.</p>
<h3 id="the-difference-between-string-and-character-literals">The difference between string and character literals</h3>
<p>String and character literals are differentiated by two indiciae:</p>
<ul>
<li>strings may have a length other than one while a <code>Char</code> type object necessarily has the length one (or potentially zero),</li>
<li>strings are introduced and terminated by double quotation marks <code>&quot;&quot;</code>, <code>Char</code> type objects are introduced by single apostrophes <code>''</code>.</li>
</ul>
<p>The second of these tends to be somewhat vexing for many programmers who are used to the equivalence of <code>''</code> and <code>&quot;&quot;</code> in languages that do not necessarily have an implemented type or class for characters mirroring <code>Char</code>. So while for instance in Python, <code>'a' == &quot;a&quot;</code> holds, this is not the case in Julia:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; typeof(<span class="st">&quot;a&quot;</span>)
    <span class="dt">ASCIIString</span> (constructor with <span class="fl">2</span> methods)
    
    julia&gt; typeof(<span class="ch">&#39;a&#39;</span>)
    <span class="dt">Char</span>
    
    julia&gt; <span class="st">&quot;a&quot;</span> == <span class="ch">&#39;a&#39;</span>
    false</code></pre>
<h3 id="heredocs-and-multiline-literals">Heredocs and multiline literals</h3>
<p>Multiline literals allow you to keep longer spans of text within a single string, with line breaks. They are introduced, similarly to Python, by triple double quotation marks <code>&quot;&quot;&quot;</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    multiline_declaration = <span class="st">&quot;&quot;&quot;</span>
        We hold these truths to be self-evident, 
        that all men are created equal,
        that they are endowed by their Creator with certain unalienable Rights, 
        that among these are Life, Liberty and the pursuit of Happiness.
        
        That to secure these rights, Governments are instituted among Men, 
        deriving their just powers from the consent of the governed...
    <span class="st">&quot;&quot;&quot;</span>
    
    julia&gt; println(multiline_declaration)
        We hold these truths to be self-evident,
        that all men are created equal,
        that they are endowed by their Creator with certain unalienable Rights,
        that among these are Life, Liberty and the pursuit of Happiness.
        
        That to secure these rights, Governments are instituted among Men,
        deriving their just powers from the consent of the governed...</code></pre>
<p>As you can see, the use of the <code>&quot;&quot;&quot;</code> or ‘heredoc’ format has preserved the line breaks and structure of the text, a rather helpful feature where longer texts are concerned.</p>
<h2 id="regex-literals">Regex literals</h2>
<p>Regular expressions (regexes) are special strings that represent particular patterns. They are useful in matching and searching text, and a good knowledge of regex should be essential knowledge for any good functional programmer.</p>
<p>To construct a regex literal, preface the string with <code>r</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; regex_literal = r<span class="st">&quot;a|e|i|o|u&quot;</span>
    r<span class="st">&quot;a|e|i|o|u&quot;</span></code></pre>
<p>This is a regex literal that matches (English) wovels. Julia recognises regex literals as the type <code>regex</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; typeof(regex_literal)
    <span class="dt">Regex</span></code></pre>
<h2 id="string-operations">String operations</h2>
<h3 id="substrings">Substrings</h3>
<p>Because strings are indexable, we can use <em>ranges</em> to select a part of a string, something we generally refer to as a <em>substring</em> or <em>string subsetting</em>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; declaration = <span class="st">&quot;When in the Course of human events&quot;</span>
    <span class="st">&quot;When in the Course of human events&quot;</span>
    
    julia&gt; declaration[<span class="fl">1</span>:<span class="fl">4</span>]
    <span class="st">&quot;When&quot;</span></code></pre>
<p>You might recall that a range might actually have a <code>step</code> attribute, which we can use to obtain every _n_th letter within a text. Let’s see every odd-numbered letter within the first few words of the Declaration of Independence:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; declaration[<span class="fl">1</span>:<span class="fl">2</span>:<span class="kw">end</span>]
    <span class="st">&quot;We nteCus fhmneet&quot;</span></code></pre>
<p>You might remember that <code>end</code>, which we used above to extend the range across the entire length of the string, behaves like a number. Therefore, you can use it to create a substring that excludes the last, say, five letters:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">     julia&gt; declaration[<span class="fl">1</span>:<span class="kw">end</span>-<span class="fl">5</span>]
     <span class="st">&quot;When in the Course of human e&quot;</span></code></pre>
<h3 id="concatenation-splitting-and-interpolation">Concatenation, splitting and interpolation</h3>
<h4 id="concatenating-and-repeating">Concatenating and repeating</h4>
<p>In most programming languages, maths and string operations correspond, so you can use <code>+</code> to concatenate and <code>*</code> to repeat a string. This is <em>not</em> the case in Julia. <code>+</code> has no method for <code>ASCIIString</code>s. What you would expect <code>+</code> to do is accomplished by <code>*</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="st">&quot;I&quot;</span> * <span class="st">&quot; &lt;3 &quot;</span> * <span class="st">&quot;Julia&quot;</span>
    <span class="st">&quot;I &lt;3 Julia&quot;</span></code></pre>
<p>So how do you multiply a sequence of text? Easy – use the <code>^</code> operator. This is useful if you happen to have been set the old school punishment of ‘lines’ (writing the same sentence all over again).</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="st">&quot;I will not say bad things about functional languages again. &quot;</span> ^ <span class="fl">10</span>
    <span class="st">&quot;I will not say bad things about functional languages again. I will not say bad things about functional languages again. I will not say bad things about functional languages again. I will not say bad things about functional languages again. I will not say bad things about functional languages again. I will not say bad things about functional languages again. I will not say bad things about functional languages again. I will not say bad things about functional languages again. I will not say bad things about functional languages again. I will not say bad things about functional languages again. &quot;</span></code></pre>
<h4 id="split"><code>split()</code></h4>
<p>The <code>split()</code> function separates a piece of text at a particular character, which it also removes. The result is an array of the chunks. By default, split() will separate at spaces, but you can provide any other string – not even necessarily a single character, as the third example shows:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; split(declaration)
    <span class="fl">7</span>-element <span class="dt">Array</span>{<span class="dt">SubString</span>{<span class="dt">ASCIIString</span>},<span class="fl">1</span>}:
     <span class="st">&quot;When&quot;</span>
     <span class="st">&quot;in&quot;</span>
     <span class="st">&quot;the&quot;</span>
     <span class="st">&quot;Course&quot;</span>
     <span class="st">&quot;of&quot;</span>
     <span class="st">&quot;human&quot;</span>
     <span class="st">&quot;events&quot;</span>
     
    julia&gt; split(declaration, <span class="st">&quot;e&quot;</span>)
    <span class="fl">6</span>-element <span class="dt">Array</span>{<span class="dt">SubString</span>{<span class="dt">ASCIIString</span>},<span class="fl">1</span>}:
     <span class="st">&quot;Wh&quot;</span>
     <span class="st">&quot;n in th&quot;</span>
     <span class="st">&quot; Cours&quot;</span>
     <span class="st">&quot; of human &quot;</span>
     <span class="st">&quot;v&quot;</span>
     <span class="st">&quot;nts&quot;</span>
     
    julia&gt; split(declaration, <span class="st">&quot;the&quot;</span>)
    <span class="fl">2</span>-element <span class="dt">Array</span>{<span class="dt">SubString</span>{<span class="dt">ASCIIString</span>},<span class="fl">1</span>}:
     <span class="st">&quot;When in &quot;</span>
     <span class="st">&quot; Course of human events&quot;</span></code></pre>
<p>If you provide <code>&quot;&quot;</code> as the string to split at, Julia will split the text into individual letters.</p>
<p>You may also use a regex to split your text at:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; regex_literal = r<span class="st">&quot;a|e|i|o|u&quot;</span>
    julia&gt; split(declaration, regex_literal)
    <span class="fl">12</span>-element <span class="dt">Array</span>{<span class="dt">SubString</span>{<span class="dt">ASCIIString</span>},<span class="fl">1</span>}:
     <span class="st">&quot;Wh&quot;</span>
     <span class="st">&quot;n &quot;</span>
     <span class="st">&quot;n th&quot;</span>
     <span class="st">&quot; C&quot;</span>
     <span class="st">&quot;&quot;</span>
     <span class="st">&quot;rs&quot;</span>
     <span class="st">&quot; &quot;</span>
     <span class="st">&quot;f h&quot;</span>
     <span class="st">&quot;m&quot;</span>
     <span class="st">&quot;n &quot;</span>
     <span class="st">&quot;v&quot;</span>
     <span class="st">&quot;nts&quot;</span></code></pre>
<p>Needless to say, since strings are immutable, the original string is not affected by the application of <code>split()</code>.</p>
<h4 id="interpolation">Interpolation</h4>
<p>String interpolation refers to the incredibly useful capability of including variable values within a string. As you might remember, we have used <code>*</code> above to concatenate strings:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; love = <span class="st">&quot;&lt;3&quot;</span>
    <span class="st">&quot;&lt;3&quot;</span>
    
    julia&gt; <span class="st">&quot;I &quot;</span> * love * <span class="st">&quot; Julia&quot;</span>
    <span class="st">&quot;I &lt;3 Julia&quot;</span></code></pre>
<p>While this is technically correct, it is much faster by using string interpolation, in which case we would refer back to the variable <code>love</code> as <code>$(love)</code> within the string. Julia knows this means it is to replace <code>$(love)</code> with the contents of the variable <code>love</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="st">&quot;I $(love) Julia&quot;</span>
    <span class="st">&quot;I &lt;3 Julia&quot;</span></code></pre>
<p>You can put anything within the parentheses in string interpolation – anything Julia knows how to handle. For instance, including an expression in a string, you get</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="st">&quot;Three plus four is $(3+4).&quot;</span>
    <span class="st">&quot;Three plus four is 7.&quot;</span></code></pre>
<p>If, and only if, you are referring to a variable, you can omit the parentheses (but not if you are referring to an expression):</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="st">&quot;I $love Julia&quot;</span>
    <span class="st">&quot;I &lt;3 Julia&quot;</span></code></pre>
<h2 id="regular-expressions-and-finding-text-within-strings">Regular expressions and finding text within strings</h2>
<p>As it has been mentioned, the main utility of regular expressions (Regexes) is to find things within long pieces of text. In the following, we will introduce the three main regex search functions of Julia - <code>match()</code>, <code>matchall()</code> and <code>eachmatch()</code>, with reference to a bit of the Declaration of Independence:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    declaration = <span class="st">&quot;We hold these truths to be self-evident, that all men are created equal, that they are endowed by their Creator with certain unalienable Rights, that among these are Life, Liberty and the pursuit of Happiness.--That to secure these rights, Governments are instituted among Men, deriving their just powers from the consent of the governed, --That whenever any Form of Government becomes destructive of these ends, it is the Right of the People to alter or to abolish it, and to institute new Government, laying its foundation on such principles and organizing its powers in such form, as to them shall seem most likely to effect their Safety and Happiness. Prudence, indeed, will dictate that Governments long established should not be changed for light and transient causes; and accordingly all experience hath shewn, that mankind are more disposed to suffer, while evils are sufferable, than to right themselves by abolishing the forms to which they are accustomed. But when a long train of abuses and usurpations, pursuing invariably the same Object evinces a design to reduce them under absolute Despotism, it is their right, it is their duty, to throw off such Government, and to provide new Guards for their future security.--Such has been the patient sufferance of these Colonies; and such is now the necessity which constrains them to alter their former Systems of Government. The history of the present King of Great Britain is a history of repeated injuries and usurpations, all having in direct object the establishment of an absolute Tyranny over these States. To prove this, let Facts be submitted to a candid world.&quot;</span></code></pre>
<p>If you are familiar with regular expressions, plod ahead! However, if</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    (GIR <span class="fl">0</span>AA)|((([A-Z-[QVX]][<span class="fl">0</span>-<span class="fl">9</span>][<span class="fl">0</span>-<span class="fl">9</span>]?)|(([A-Z-[QVX]][A-Z-[IJZ]][<span class="fl">0</span>-<span class="fl">9</span>][<span class="fl">0</span>-<span class="fl">9</span>]?)|(([A-Z-[QVX]][<span class="fl">0</span>-<span class="fl">9</span>][A-HJKSTUW])|([A-Z-[QVX]][A-Z-[IJZ]][<span class="fl">0</span>-<span class="fl">9</span>][ABEHMNPRVWXY])))) [<span class="fl">0</span>-<span class="fl">9</span>][A-Z-[CIKMOV]]{<span class="fl">2</span>})</code></pre>
<p>looks like gobbledygook to you or you feel your regex fu is a little rusty, put down this book and consult the <a href="http://www.rexegg.com/regex-quickstart.html#ref">Regex cheatsheet</a> or, even better, <a href="http://regex.info/book.html">Jeffrey Friedl’s amazing book on mastering regexes</a>.</p>
<h3 id="finding-and-replacing-using-the-search-function">Finding and replacing using the <code>search()</code> function</h3>
<p>If you are only concerned with finding a single instance of a search term within a string, the <code>search()</code> function returns the range index of where the search expression appears:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; search(declaration, <span class="st">&quot;Government&quot;</span>)
    <span class="fl">241</span>:<span class="fl">250</span></code></pre>
<p><code>search()</code> also accepts regular expressions:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; search(declaration, r<span class="st">&quot;th.{2,3}&quot;</span>)
    <span class="fl">9</span>:<span class="fl">13</span></code></pre>
<p>To retrieve the result, rather than its index, you can pass the resulting index off to the string as the subsetting range, using the square bracket <code>[]</code> syntax:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; declaration[search(declaration, r<span class="st">&quot;th.{2,3}&quot;</span>)]
    <span class="st">&quot;these&quot;</span></code></pre>
<p>Ah, so that’s the word it found!</p>
<p>Where a search string is not found, <code>search()</code> will yield <code>0:-1</code>. That is an odd result, until you realise the reason: for any string <code>s</code>, <code>s[0:-1]</code> will necessarily yield <code>&quot;&quot;</code> (that is, an empty string).</p>
<h3 id="finding-using-the-match-family-of-functions">Finding using the <code>match()</code> family of functions</h3>
<p>The problem with <code>search()</code> is that it retrieves one, and only one, result – the first within the string passed to it. The <code>match()</code> family of functions can help us with finding more results:</p>
<ul>
<li><code>match()</code> retrieves <em>either the first match or nothing</em> within the text,</li>
<li><code>matchall()</code> returns <em>an array of all matching substrings</em>, and</li>
<li><code>eachmatch()</code> returns an <em>iterator over all matches</em>.</li>
</ul>
<p>The <code>match()</code> family of functions needs a regular expression literal as a search argument. This is so even if the regular expression does not make use of any pattern matching beyond a simple string. Thus,</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; match(r<span class="st">&quot;truths&quot;</span>, declaration)</code></pre>
<p>is valid, while</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; match(<span class="st">&quot;truths&quot;</span>, declaration)</code></pre>
<p>yields an error:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    ERROR: `match` has no method matching match(::<span class="dt">ASCIIString</span>, ::<span class="dt">ASCIIString</span>)</code></pre>
<h4 id="understanding-regexmatch-objects">Understanding <code>RegexMatch</code> objects</h4>
<p>Most regex search functions return an object of type <code>RegexMatch</code>. As the name reveals, a <code>RegexMatch</code> is a composite type representing a match. As such, it encapsulates (to use a little more OOP terminology than one would normally be allowed to in a book on functional programming) four values, the first three of which will be of immediate interest to us:</p>
<ul>
<li><code>RegexMatch.match</code> is the matched substring,</li>
<li><code>RegexMatch.captures</code> is an array of types that represent the type of what the regex would capture,</li>
<li><code>RegexMatch.offset</code> is generally an <code>Int64</code> that represents the index of the first character of the matched string where there is a single match (e.g. when using <code>match()</code>).</li>
</ul>
<p>To illustrate, let’s consider the result of a <code>match()</code> call, which will be introduced in the next subsection:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    m = match(r<span class="st">&quot;That .*?,&quot;</span>, declaration)
    
    julia&gt; m.match
    <span class="st">&quot;That to secure these rights,&quot;</span>
    
    julia&gt; m.captures
    <span class="fl">0</span>-element <span class="dt">Array</span>{<span class="dt">Union</span>(<span class="dt">SubString</span>{<span class="dt">UTF8String</span>},<span class="dt">Nothing</span>),<span class="fl">1</span>}
    
    julia&gt; m.offset
    <span class="fl">212</span></code></pre>
<h4 id="match"><code>match()</code></h4>
<p><code>match()</code> retrieves the first match or nothing - in this sense, it is rather similar to <code>search()</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; match(r<span class="st">&quot;That .*?,&quot;</span>, declaration)
    <span class="dt">RegexMatch</span>(<span class="st">&quot;That to secure these rights,&quot;</span>)</code></pre>
<p>The result is a <code>RegexMatch</code> object. The object can be inspected using <code>.match</code> (e.g. <code>match(r&quot;truths&quot;, declaration).match</code>).</p>
<h4 id="matchall"><code>matchall()</code></h4>
<p><code>matchall()</code> returns an array of matching substrings, which is sometimes a little easier to use:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; matchall(r<span class="st">&quot;That .*?,&quot;</span>, declaration)
    <span class="fl">2</span>-element <span class="dt">Array</span>{<span class="dt">SubString</span>{<span class="dt">UTF8String</span>},<span class="fl">1</span>}:
     <span class="st">&quot;That to secure these rights,&quot;</span>
     <span class="st">&quot;That whenever any Form of Government becomes destructive of these ends,&quot;</span></code></pre>
<h4 id="eachmatch"><code>eachmatch()</code></h4>
<p><code>eachmatch()</code> returns an object known as an iterator, specifically of the type <code>RegexMatchIterator</code>. We have on and off encountered iterators, but we will not really deal with them in depth until chapter [X], which deals with control flow. Suffice it to say an iterator is an object that containts a list of items that can be iterated through. The iterator will iterate over a list of <code>RegexMatch</code> objects, so if we want the results themselves, we will need to call the <code>.match</code> method on each of them:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">for</span> i <span class="kw">in</span> eachmatch(r<span class="st">&quot;That .*?,&quot;</span>, declaration)
        println(<span class="st">&quot;A matching search result is: $(i.match)&quot;</span>)
    <span class="kw">end</span></code></pre>
<p>The result is quite similar to that returned by <code>matchall()</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    A matching search result is: That to secure these rights,
    A matching search result is: That whenever any Form of Government becomes destructive of these ends,</code></pre>
<h4 id="ismatch"><code>ismatch()</code></h4>
<p><code>ismatch()</code> returns a boolean value depending on whether the search text contains a match for the regex provided.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; ismatch(r<span class="st">&quot;truth(s)?&quot;</span>, declaration)
    true
    
    julia&gt; ismatch(r<span class="st">&quot;sausage(s)?&quot;</span>, declaration)
    false</code></pre>
<h3 id="replacing-substrings">Replacing substrings</h3>
<p>Julia can replace substrings using the <code>replace()</code> syntax… let’s try putting some sausages into the Declaration of Independence!</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; replace(declaration, <span class="st">&quot;truth&quot;</span>, <span class="st">&quot;sausage&quot;</span>)
    <span class="st">&quot;We hold these sausages to be self-evident, that all men are created equal,...&quot;</span></code></pre>
<p>An interesting feature of <code>replace()</code> is that the replacement does not need to be a string. In fact, it is possible to pass a function as the third argument (as always, without the parentheses <code>()</code> that signify a function call). Julia will interpret this as ‘replace the substring with the result of passing the substring to this function’:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; replace(declaration, <span class="st">&quot;truth&quot;</span>, uppercase)
    <span class="st">&quot;We hold these TRUTHs to be self-evident, that all men are created equal,...&quot;</span></code></pre>
<p>Much more dignified than self-evident sausages, I’d say! At risk of repeating myself, it is important to note that since strings are immutable, <code>replace()</code> merely returns a copy of the string with the search string replaced by the replacement string or the result of the replacement function, and the original string itself will remain unaffected.</p>
<p>Where the substring is not found, the result will be, unsurprisingly, an unaltered string.</p>
<h3 id="regex-flags">Regex flags</h3>
<p>A little-known feature of Julia regexes is the ability for a regex to be appended one or more flags. These, like most of Julia’s regex capability, derive from Perl’s regex module <code>perlre</code>.</p>
<table>
<thead>
<tr class="header">
<th align="center">Flag</th>
<th align="left">Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">i</td>
<td align="left">Case-insensitive pattern matching</td>
</tr>
<tr class="even">
<td align="center">m</td>
<td align="left">Treats string as a multiline string, so that <code>^</code> and <code>$</code> will refer to the start or end of any line within the string.</td>
</tr>
<tr class="odd">
<td align="center">s</td>
<td align="left">Treats line as a single line. This will result in <code>.</code> accepting a newline as well. When used together with <code>m</code>, it will result in <code>.</code> matching every possible character while still allowing <code>^</code> and <code>$</code> to match, just after and just before newlines within the string.</td>
</tr>
<tr class="even">
<td align="center">x</td>
<td align="left">Ignore non-backslashed, non-classed whitespace.</td>
</tr>
</tbody>
</table>
<p>Flags are appended to the end of each regex, which might strike users more familiar with e.g. the Pythonic way of modifying the regex search object itself, as somewhat unusual:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    multiline = r<span class="st">&quot;^We&quot;</span>m</code></pre>
<p>In this case, the regex <code>r&quot;^We&quot;</code> was augmented by the multiline flag, appended at its end.</p>
<h2 id="string-transformation-and-testing">String transformation and testing</h2>
<h3 id="case-transformations">Case transformations</h3>
<p>Case transformations are functions that act on <code>String</code>s and transform character case. Let’s examine the effect of these transformations in turn.</p>
<table>
<thead>
<tr class="header">
<th align="center">Function</th>
<th align="left">Effect</th>
<th align="left">Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><code>uppercase()</code></td>
<td align="left">Converts the entire string to upper-case characters</td>
<td align="left"><code>WE HOLD THESE TRUTHS TO BE SELF-EVIDENT</code></td>
</tr>
<tr class="even">
<td align="center"><code>lowercase()</code></td>
<td align="left">Converts the entire string to lower-case characters</td>
<td align="left"><code>we hold these truths to be self-evident</code></td>
</tr>
<tr class="odd">
<td align="center"><code>ucfirst()</code></td>
<td align="left">Converts the first character of the string to upper-case</td>
<td align="left"><code>We hold these truths to be self-evident</code></td>
</tr>
<tr class="even">
<td align="center"><code>lcfirst()</code></td>
<td align="left">Converts the first character of the string ot lower-case</td>
<td align="left"><code>we hold these truths to be self-evident</code></td>
</tr>
</tbody>
</table>
<h3 id="testing-and-attributes">Testing and attributes</h3>
<p><TODO: To be written...> # Chapter 6: Control flow</p>
<p>So far, we’ve looked at variables, types, strings and collections – in short, the things programs operate on. Control flow is where we start to delve into <em>how</em> to engineer programs that do what we need them to.</p>
<p>We will be encountering two new things in this chapter. First, we will be coming across a number of <em>keywords</em>. Functional languages are generally known for having a minimum of keywords, but they usually still need some. A keyword is a word that has a particular role in the syntax of Julia. Keywords are <em>not functions</em>, and therefore are <em>not called</em> (so no need for parentheses at the end!).</p>
<p>The second new concept is that of <em>blocks</em>. Blocks are chunks of expressions that are ‘set aside’ because they are, for instance, executed if a certain criterion is met. Blocks start with a starting expression, are followed by indented lines and end on an unindented line with the <code>end</code> keyword. A typical block would be:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">if</span> variable1 &gt; variable2
        println(<span class="st">&quot;Variable 1 is larger than Variable 2.&quot;</span>)
    <span class="kw">end</span></code></pre>
<p>In Julia, blocks are normally indented as a matter of convention, but as long as they’re validly terminated with the <code>end</code> keyword, it’s all good. They are not surrounded by any special characters (such as curly braces <code>{}</code> that are common in Java or Javascript) or terminators after the condition (such as the colon <code>:</code> in Python). It is up to you whether you put the condition in parentheses <code>()</code>, but this is not required and is not an unambiguously useful feature at any rate. <code>if</code> and <code>elseif</code> are keywords, and as such they are not ‘called’ but invoked, so using the parentheses would not be technically appropriate.</p>
<h2 id="conditions-truth-values-and-comparisons">Conditions, truth values and comparisons</h2>
<p>Much of control flow depends on the evaluation of particular conditions. Thus, for instance, an <code>if</code>/<code>else</code> construct may perform one action if a condition is true and a different one if it is false. Therefore, it is important to understand the role comparisons play in control flow and their effective (and idiomatic) use.</p>
<h3 id="comparison-operators">Comparison operators</h3>
<p>Julia has six comparison operators. Each of these acts differently depending on what types it is used on, therefore we’ll take the effect of each of these operators in turn depending on their types. Unlike a number of programming languages, Julia’s Unicode support means it can use a wider range of symbols as operators, which makes for prettier code but might be inadvisable – the difference between <code>&gt;=</code> and <code>&gt;</code> is less ambiguous than the difference between <code>≥</code> and <code>&gt;</code>, especially at small resolutions.</p>
<table>
<thead>
<tr class="header">
<th align="left">Operator</th>
<th align="left">Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>==</code> or <code>isequal(x,y)</code></td>
<td align="left">equality</td>
</tr>
<tr class="even">
<td align="left"><code>!=</code> or <code>≠</code></td>
<td align="left">inequality</td>
</tr>
<tr class="odd">
<td align="left"><code>&lt;</code></td>
<td align="left">less than</td>
</tr>
<tr class="even">
<td align="left"><code>&lt;=</code> or <code>≤</code></td>
<td align="left">less or equal</td>
</tr>
<tr class="odd">
<td align="left"><code>&gt;</code></td>
<td align="left">greater than</td>
</tr>
<tr class="even">
<td align="left"><code>&gt;=</code> or <code>≥</code></td>
<td align="left">greater or equal</td>
</tr>
</tbody>
</table>
<h4 id="numeric-comparison">Numeric comparison</h4>
<p>When comparing numeric types, the comparison operators act as one would expect them, with some conventions that derive from the <a href="http://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754 standard</a> for floating point values.</p>
<p>Numeric comparison can accommodate three ‘special’ values: <code>-Inf</code>, <code>Inf</code> and <code>NaN</code>, which might be familiar from <code>R</code> or other programming languages. The paradigms for these three are that</p>
<ul>
<li><code>NaN</code> is not equal to, larger than or less than anything, including itself (<code>NaN == NaN</code> yields <code>false</code>),</li>
<li><code>-Inf</code> and <code>Inf</code> are each equal to themselves but not the other (<code>-Inf == -Inf</code> yields <code>true</code> but <code>-Inf == Inf</code> is false),</li>
<li><code>Inf</code> is greater than everything except <code>NaN</code>,</li>
<li><code>-Inf</code> is smaller than everything except <code>NaN</code>.</li>
<li><code>-0</code> is equal to <code>0</code> or <code>+0</code>, but not smaller.</li>
</ul>
<p>Julia also provides a function called <code>isequal()</code>, which at first sight appears to mirror the <code>==</code> operator, but has a few peculiarities:</p>
<ul>
<li><code>NaN != NaN</code>, but <code>isequal(NaN, NaN)</code> yields true,</li>
<li><code>-0 == 0</code>, but <code>isequal(-0, 0)</code> yields true.</li>
</ul>
<h4 id="char-comparisons"><code>Char</code> comparisons</h4>
<p><code>Char</code> comparison is based on the <em>integer value</em> of every <code>Char</code>, which is its position in the code table (which you can obtain by using <code>int()</code>: <code>int('a') = 97</code>).</p>
<p>As a result, the following will hold:</p>
<ul>
<li>A <code>Char</code> of a lowercase letter will be larger than the <code>Char</code> of the same letter in uppercase: <code>'A' &gt; 'a'</code> yields false,</li>
<li>A <code>Char</code> plus or minus an integer yields a <code>Char</code>, which is the initial character offset by the integer: <code>'A' + 4</code> yields <code>'E'</code>.</li>
<li>A <code>Char</code> plus or minus another <code>Char</code> yields an <code>Int</code>, which is the offset between the two characters: <code>'E' - 'A'</code> yields <code>4</code>.</li>
</ul>
<p>A lot of this is a little counter-intuitive, but what you need to remember is that <code>Char</code>s are merely numerical references to where the character is located, and this is used to do comparisons.</p>
<h4 id="string-comparisons"><code>String</code> comparisons</h4>
<p>For <code>AbstractString</code> descendants, comparison will be based on <em>lexicographical comparison</em> – or, to put it in human terms, where they would relatively be in a lexicon.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="st">&quot;truths&quot;</span> &gt; <span class="st">&quot;sausages&quot;</span>
    true</code></pre>
<p>For words starting with the same characters in different cases, lowercase characters come after (i.e. are larger than) uppercase characters, much like in <code>Char</code> comparisons:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="st">&quot;Truths&quot;</span> &lt; <span class="st">&quot;truths&quot;</span>
    true</code></pre>
<h4 id="chaining-comparisons">Chaining comparisons</h4>
<p>Julia allows you to execute multiple comparisons – this is, indeed, encouraged, as it allows you to reflect mathematical relationships better and clearer in code. Comparison chaining associates from right to left:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="fl">3</span> &lt; π &lt; <span class="fl">4</span>
    true
    
    julia&gt; <span class="fl">5</span> ≥ π &lt; <span class="fl">12</span> &gt; <span class="fl">3</span>*e
    true</code></pre>
<h4 id="combining-comparisons">Combining comparisons</h4>
<p>Comparisons can be combined using the boolean operators <code>&amp;&amp;</code> (<code>and</code>) and <code>||</code> (<code>or</code>). The truth table of these operators is</p>
<table>
<thead>
<tr class="header">
<th align="center">Expression</th>
<th align="left"><code>a</code></th>
<th align="left"><code>b</code></th>
<th align="left">result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><code>a &amp;&amp; b</code></td>
<td align="left">true</td>
<td align="left">true</td>
<td align="left">true</td>
</tr>
<tr class="even">
<td align="center"></td>
<td align="left">false</td>
<td align="left">true</td>
<td align="left">false</td>
</tr>
<tr class="odd">
<td align="center"></td>
<td align="left">true</td>
<td align="left">false</td>
<td align="left">false</td>
</tr>
<tr class="even">
<td align="center"></td>
<td align="left">false</td>
<td align="left">false</td>
<td align="left">false</td>
</tr>
<tr class="odd">
<td align="center"><code>a || b</code></td>
<td align="left">true</td>
<td align="left">true</td>
<td align="left">true</td>
</tr>
<tr class="even">
<td align="center"></td>
<td align="left">false</td>
<td align="left">true</td>
<td align="left">true</td>
</tr>
<tr class="odd">
<td align="center"></td>
<td align="left">true</td>
<td align="left">false</td>
<td align="left">true</td>
</tr>
<tr class="even">
<td align="center"></td>
<td align="left">false</td>
<td align="left">false</td>
<td align="left">false</td>
</tr>
</tbody>
</table>
<p>Therefore,</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; π &gt; <span class="fl">2</span> &amp;&amp; π &lt; <span class="fl">3</span>
    false
    
    julia&gt; π &gt; <span class="fl">2</span> || π &lt; <span class="fl">3</span>
    true</code></pre>
<h3 id="truthiness">Truthiness</h3>
<p>No, it’s not the Colbert version. Truthiness refers to whether a variable that is not a boolean variable (<code>true</code> or <code>false</code>) is evaluated as true or false.</p>
<h4 id="definition-truthiness">Definition truthiness</h4>
<p>Julia is fairly strict with existence truthiness. A non-existent variable being tested for doesn’t yield <code>false</code>, it yields an error.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="kw">if</span> seahawks
               println(<span class="st">&quot;We know the Seahawks&#39; lineup.&quot;</span>)
           <span class="kw">else</span>
               println(<span class="st">&quot;We don&#39;t know the Seahawks&#39; lineup.&quot;</span>)
           <span class="kw">end</span>
    ERROR: seahawks not defined</code></pre>
<p>Now let’s create an empty array named <code>seahawks</code> which will, one day, accommodate their lineup:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; seahawks = <span class="dt">Array</span>{<span class="dt">ASCIIString</span>}
    <span class="dt">Array</span>{<span class="dt">ASCIIString</span>,N}</code></pre>
<p>Will existence of the array, empty though it may be, yield a truthy result? Not in Julia. It will yield, again, an error:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="kw">if</span> seahawks
               println(<span class="st">&quot;We know the Seahawks&#39; lineup.&quot;</span>)
           <span class="kw">else</span>
               println(<span class="st">&quot;We don&#39;t know the Seahawks&#39; lineup.&quot;</span>)
           <span class="kw">end</span>
    ERROR: <span class="kw">type</span>: non-boolean (DataType) used <span class="kw">in</span> boolean context</code></pre>
<h4 id="value-truthiness">Value truthiness</h4>
<p>Nor will common values yield the usual truthiness results. 0, which in some languages would yield a <code>false</code>, will again result in an error:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; seahawks = <span class="fl">0</span>
    <span class="fl">0</span>
    
    julia&gt; <span class="kw">if</span> seahawks
               println(<span class="st">&quot;We know the Seahawks&#39; lineup.&quot;</span>)
           <span class="kw">else</span>
               println(<span class="st">&quot;We don&#39;t know the Seahawks&#39; lineup.&quot;</span>)
           <span class="kw">end</span>
    ERROR: <span class="kw">type</span>: non-boolean (<span class="dt">Int64</span>) used <span class="kw">in</span> boolean context</code></pre>
<p>The same goes for any other value. The bottom line, for you as a programmer, is that anything but <code>true</code> or <code>false</code> as the result of evaluating a condition yields an <code>error</code> and if you wish to make use of what you would solve with truthiness in another language, you might need to explicitly test for existence or value by using a function in your conditional expression that tests for existence or value, respectively.</p>
<h4 id="implementing-definition-truthiness">Implementing definition truthiness</h4>
<p>To implement definition truthiness, Julia helpfully provides the <code>isdefined()</code> function, which yields true if a symbol is defined. Be sure to pass the symbol, not the value, to the function by prefacing it with a colon <code>:</code>, as in this case:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="kw">if</span> isdefined(:seahawks)
               println(<span class="st">&quot;We know the Seahawks&#39; lineup.&quot;</span>)
           <span class="kw">else</span>
               println(<span class="st">&quot;We don&#39;t know the Seahawks&#39; lineup.&quot;</span>)
           <span class="kw">end</span>
    We know the Seahawks&#39; lineup.</code></pre>
<h2 id="ifelseifelse-and-boolean-switching"><code>if</code>/<code>elseif</code>/<code>else</code>, <code>?</code>/<code>:</code> and boolean switching</h2>
<p><em>Conditional evaluation</em> refers to the programming practice of evaluating a block of code if, and only if, a particular <em>condition</em> is met (i.e. if the expression used as the condition returns <code>true</code>). In Julia, this is implemented using the <code>if</code>/<code>elseif</code>/<code>else</code> syntax, the <em>ternary operator</em>, <code>?:</code> or boolean switching:</p>
<h3 id="ifelseifelse-syntax"><code>if</code>/<code>elseif</code>/<code>else</code> syntax</h3>
<p>A typical conditional evaluation block consists of an <code>if</code> statement and a condition.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">if</span> <span class="st">&quot;A&quot;</span> == <span class="st">&quot;A&quot;</span>
        println(<span class="st">&quot;Aristotle was right.&quot;</span>)
    <span class="kw">end</span></code></pre>
<p>Julia further allows you to include as many further cases as you wish, using <code>elseif</code>, and a catch-all case that would be called <code>else</code> and have no condition attached to it:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">if</span> weather == <span class="st">&quot;rainy&quot;</span>
        println(<span class="st">&quot;Bring your umbrella.&quot;</span>)
    <span class="kw">elseif</span> weather == <span class="st">&quot;windy&quot;</span>
        println(<span class="st">&quot;Dress up warm!&quot;</span>)
    <span class="kw">elseif</span> weather == <span class="st">&quot;sunny&quot;</span>
        println(<span class="st">&quot;Don&#39;t forget sunscreen!&quot;</span>)
    <span class="kw">else</span>
        println(<span class="st">&quot;Check the darn weather yourself, I have no idea.&quot;</span>)</code></pre>
<p>For <code>weather = &quot;rainy&quot;</code>, this predictably yields</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    Bring your umbrella.</code></pre>
<p>while for <code>weather = &quot;warm&quot;</code>, we get</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    Check the darn weather yourself, I have no idea.</code></pre>
<h3 id="ternary-operator">Ternary operator <code>?</code>/<code>:</code></h3>
<p>The ternary operator is a useful way to put a reasonably simple conditional expression into a single line of code. The ternary operator <em>does not create a block</em>, therefore there is no need to suffix it with the <code>end</code> keyword. Rather, you enter the condition, then separate it with a <code>?</code> from the result of the true and the false outcomes, each in turn separated by a colon <code>:</code>, as in this case:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; x = <span class="fl">0.3</span>
    <span class="fl">0.3</span>
    
    julia&gt; x &lt; π/<span class="fl">2</span> ? sin(x) : cos(x)
    <span class="fl">0.29552020666133955</span></code></pre>
<p>Ternary operators are great for writing simple conditionals quickly, but can make code unduly confusing. A number of style guides generally recommend using them sparingly. Some programmers, especially those coming from Java, like using a multiline notation, which makes it somewhat more legible while still not requiring a block to be created:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; x &lt; π/<span class="fl">2</span> ?
               sin(x) :
               cos(x)
    <span class="fl">0.29552020666133955</span></code></pre>
<h3 id="boolean-switching-and">Boolean switching <code>||</code> and <code>&amp;&amp;</code></h3>
<p>Boolean switching, which the Julia documentation refers to as <em>short-circuit evaluation</em>, allows you quickly evaluate using boolean operators. It uses two operators:</p>
<table>
<thead>
<tr class="header">
<th align="center">Operator</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><code>a || b</code></td>
<td align="left">Execute <code>b</code> if <code>a</code> evaluates to <code>false</code></td>
</tr>
<tr class="even">
<td align="center"><code>a &amp;&amp; b</code></td>
<td align="left">Execute <code>b</code> if <code>a</code> evaluates to true</td>
</tr>
</tbody>
</table>
<p>These derive from the boolean use of <code>&amp;&amp;</code> and <code>||</code>, where <code>&amp;&amp;</code> means <code>and</code> and <code>||</code> means <code>or</code> - the logic being that for a <code>&amp;&amp;</code> operator, if <code>a</code> is false, <code>a &amp;&amp; b</code> will be false, <code>b</code>’s value regardless. <code>||</code>, on the other hand, will necessarily be true if <code>a</code> is true. It might be a bit difficult to get one’s head around it, so what you need to remember is the following equivalence:</p>
<ul>
<li><code>if &lt;condition&gt; &lt;statement&gt;</code> is equivalent to <code>condition &amp;&amp; statement</code>, and</li>
<li><code>if !&lt;condition&gt; &lt;statement&gt;</code> is equivalent to <code>condition || statement</code>.</li>
</ul>
<p>Thus, let us consider the following:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; isprime(is_this_a_prime) &amp;&amp; println(<span class="st">&quot;Yes, it is.&quot;</span>)
    Yes, it is.
    
    julia&gt; isprime(is_this_a_prime) || println(<span class="st">&quot;No, it isn&#39;t.&quot;</span>)
    true
    
    julia&gt; is_this_a_prime = <span class="fl">8</span>
    <span class="fl">8</span>
    
    julia&gt; isprime(is_this_a_prime) || println(<span class="st">&quot;No, it isn&#39;t.&quot;</span>)
    No, it isn&#39;t.</code></pre>
<p>It is rather counter-intuitive, but the alternative to it executing the code after the boolean operator is returning <code>true</code> or <code>false</code>. This shoud not necessarily trouble us, since our focus on getting our instructions executed. Outside the REPL, what each of these functions return is irrelevant.</p>
<h2 id="while"><code>while</code></h2>
<p>With <code>while</code>, we’re entering the world of repeated (or <em>iterative</em>) evaluation. The idea of <code>while</code> is quite simple: as long as a condition is met, execution will continue. The famed words of the pirate captain whose name has never been submitted to history can be rendered in a <code>while</code> clause thus:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">while</span> morale != improved
        continue_flogging()
    <span class="kw">end</span></code></pre>
<p><code>while</code>, along with <code>for</code>, is a <em>loop operator</em>, meaning - unsurprisingly - that it creates a loop that is executed over and over again until the conditional variable changes. While <code>for</code> loops generally need a limited range in which they are allowed to run, <code>while</code> loops can sometimes become infinite and turn into <em>runaway loops</em>. This is best avoided, not the least because it tends to crash systems or at the very least take up capacity for no good reason.</p>
<h3 id="breaking-a-while-loop-break">Breaking a <code>while</code> loop: <code>break</code></h3>
<p>A <code>while</code> loop can be terminated by the <code>break</code> keyword prematurely (that is, before it has reached its condition). Thus, the following loop would only be executed five times, not ten:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">while</span> i &lt; <span class="fl">10</span></code></pre>
<pre><code>    i += 1
    println(&quot;The value of i is &quot;, i)
    if i == 5
        break
    end
end</code></pre>
<p>The result is:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    The value of i is <span class="fl">1</span>
    The value of i is <span class="fl">2</span>
    The value of i is <span class="fl">3</span>
    The value of i is <span class="fl">4</span>
    The value of i is <span class="fl">5</span></code></pre>
<p>This is because after five evaluations, the conditional would have evaluated to true and led to the <code>break</code> keyword breaking the loop.</p>
<h3 id="skipping-over-results-continue">Skipping over results: <code>continue</code></h3>
<p>Let’s assume we have suffered a grievous blow to our heads and forgotten all we knew about <code>for</code> loops and negation. Through some odd twist of fate, we absolutely <em>need</em> to list all non-primes from one to ten, and we need to use a <code>while</code> loop for this.</p>
<p>The <code>continue</code> keyword instructs a loop to finish evaluating the current value of the iterator and go to the next. As such, you would want to put it as early as possible - there is no use instructing Julia to stop looking at the current iterator when</p>
<h2 id="for"><code>for</code></h2>
<p>Like <code>while</code>, <code>for</code> is a loop operator. Unlike <code>while</code>, it operates not <em>as long as</em> a condition is met but rather until it has burned through an <em>iterable</em>. As we have seen, a number of objects consist of smaller chunks and are capable of being iterated over this, one by one. The archetypical iterable is a <code>Range</code> object. In the following, we will use a <code>Range</code> literal (created by a colon <code>:</code>) from one to 10 in steps of 2, and get Julia to tell us which numbers in that range are primes:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="kw">for</span> i <span class="kw">in</span> <span class="fl">1</span>:<span class="fl">2</span>:<span class="fl">10</span>
               println(isprime(i))
           <span class="kw">end</span>
    false
    true
    true
    true
    false</code></pre>
<h3 id="iterating-over-indexable-collections">Iterating over indexable collections</h3>
<p>Other iterables include indexable collections:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="kw">for</span> j <span class="kw">in</span> [<span class="ch">&#39;r&#39;</span>, <span class="ch">&#39;o&#39;</span>, <span class="ch">&#39;y&#39;</span>, <span class="ch">&#39;g&#39;</span>, <span class="ch">&#39;b&#39;</span>, <span class="ch">&#39;i&#39;</span>, <span class="ch">&#39;v&#39;</span>]
               println(j)
           <span class="kw">end</span>
    r
    o
    y
    g
    b
    i
    v</code></pre>
<p>This includes, incidentally, multidimensional arrays – but don’t forget the direction of iteration (column by column, top-down):</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    ulia&gt; md_array = [<span class="fl">1</span> <span class="fl">1</span> <span class="fl">2</span> <span class="fl">3</span> <span class="fl">5</span>; <span class="fl">8</span> <span class="fl">13</span> <span class="fl">21</span> <span class="fl">34</span> <span class="fl">55</span>; <span class="fl">89</span> <span class="fl">144</span> <span class="fl">233</span> <span class="fl">377</span> <span class="fl">610</span>]
    <span class="fl">3</span>x5 <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">2</span>}:
      <span class="fl">1</span>    <span class="fl">1</span>    <span class="fl">2</span>    <span class="fl">3</span>    <span class="fl">5</span>
      <span class="fl">8</span>   <span class="fl">13</span>   <span class="fl">21</span>   <span class="fl">34</span>   <span class="fl">55</span>
     <span class="fl">89</span>  <span class="fl">144</span>  <span class="fl">233</span>  <span class="fl">377</span>  <span class="fl">610</span>
     
    julia&gt; <span class="kw">for</span> each <span class="kw">in</span> md_array
               println(each)
           <span class="kw">end</span>
    <span class="fl">1</span>
    <span class="fl">8</span>
    <span class="fl">89</span>
    ...
    <span class="fl">55</span>
    <span class="fl">610</span></code></pre>
<h3 id="iterating-over-dicts">Iterating over dicts</h3>
<p>As we have seen, dicts are non-indexable. Nevertheless, Julia can iterate over a dict. There are two ways to accomplish this.</p>
<h4 id="tuple-iteration">Tuple iteration</h4>
<p>In tuple iteration, each key-value pair is seen as a tuple and returned as such:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="kw">for</span> statistician <span class="kw">in</span> statisticians
               println(<span class="st">&quot;$(statistician[1]) lived $(statistician[2]).&quot;</span>)
           <span class="kw">end</span>
    Galton lived <span class="fl">1822</span>-<span class="fl">1911</span>.
    Pearson lived <span class="fl">1857</span>-<span class="fl">1936</span>.
    Gosset lived <span class="fl">1876</span>-<span class="fl">1937</span>.</code></pre>
<p>While this does the job, it is not particularly graceful. It is, however, useful if we need to have the key and the value in the same object, such as in the case of conversion scripts often encountered in ‘data munging’.</p>
<h4 id="key-value-kv-iteration">Key-value (<code>k,v</code>) iteration</h4>
<p>A better way to iterate over a dict assigns two variables, rather than one, as iterators, one each for the key and the value. In this syntax, the above could be re-written as:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="kw">for</span> (name,years) <span class="kw">in</span> statisticians
               println(<span class="st">&quot;$name lived $years.&quot;</span>)
           <span class="kw">end</span></code></pre>
<h3 id="iteration-over-strings">Iteration over strings</h3>
<p>Iteration over a string results in iteration over each character. The individual characters are interpreted as objects of type <code>Char</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="kw">for</span> each <span class="kw">in</span> <span class="st">&quot;Sausage&quot;</span>
               println(<span class="st">&quot;$each is of the type $(typeof(each))&quot;</span>)
           <span class="kw">end</span>
    S is of the <span class="kw">type</span> <span class="dt">Char</span>
    a is of the <span class="kw">type</span> <span class="dt">Char</span>
    u is of the <span class="kw">type</span> <span class="dt">Char</span>
    s is of the <span class="kw">type</span> <span class="dt">Char</span>
    a is of the <span class="kw">type</span> <span class="dt">Char</span>
    g is of the <span class="kw">type</span> <span class="dt">Char</span>
    e is of the <span class="kw">type</span> <span class="dt">Char</span></code></pre>
<h2 id="compound-expressions-beginend-and">Compound expressions: <code>begin</code>/<code>end</code> and <code>;</code></h2>
<p>A <em>compound expression</em> is somewhat similar to a function in that it is a pre-defined sequence of functions that is executed one by one. Compound expressions allow you to execute small and concise blocks of code in sequence and return the result of the last calculation. There are two ways to create compound expressions, using a <code>begin</code>/<code>end</code> syntax creating a block or surrounding the compound expression with parentheses <code>()</code> and delimiting each instruction with <code>;</code>.</p>
<h3 id="beginend-blocks"><code>begin</code>/<code>end</code> blocks</h3>
<p>A <code>begin</code>/<code>end</code> structure creates a block and returns the result of the last line evaluated.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; circumference = <span class="kw">begin</span>
               r = <span class="fl">3</span>
               <span class="fl">2</span>*r*π
           <span class="kw">end</span>
    <span class="fl">18.84955592153876</span></code></pre>
<h3 id="syntax"><code>;</code> syntax</h3>
<p>One of the benefits of compound expressions is the ability to put a lot into a small space. This is where the <code>;</code> syntax shines. Somewhat similar to anonymous functions or <code>lambda</code>s in other languages, such as Python, you can simplify the calculation above to</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; circumference = (r = <span class="fl">3</span>; <span class="fl">2</span>*r*π)
    <span class="fl">18.84955592153876</span></code></pre>
<h1 id="chapter-7-functions-and-methods">Chapter 7: Functions and methods</h1>
<p>Julia is what is described as a <em>functional programming language</em>, meaning that functions are the principal building blocks of a Julia program (as opposed to objects and their instances in OOP). Introducing functions is the last part we are missing before we can start building fully-fledged applications to solve real world problems. Let’s get cracking!</p>
<h2 id="syntax-and-arguments">Syntax and arguments</h2>
<h3 id="general-syntax-and-invocation">General syntax and invocation</h3>
<p>There are two general ways to define a function. The first way is usually suited for simple, single-expression functions, while the second way is more suitable for longer functions that include multiple expressions.</p>
<h4 id="single-expression-functions">Single expression functions</h4>
<p>Single expression functions are written very similarly to their mathematical form:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; geom_average(a,b) = sqrt(a^<span class="fl">2</span> + b^<span class="fl">2</span>)
    geom_average (generic <span class="kw">function</span> with <span class="fl">1</span> method)
    
    julia&gt; geom_average(<span class="fl">3</span>,<span class="fl">4</span>)
    <span class="fl">5.0</span></code></pre>
<h4 id="multiple-expression-functions">Multiple expression functions</h4>
<p>If your function is more complex, and needs to evaluate multiple functions, this syntax is no longer suitable. The syntax to use in such cases uses a block, introduced by <code>function</code> and terminated by <code>end</code>, to describe the function:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="kw">function</span> breakfast(pancakes, coffee)
               println(<span class="st">&quot;$coffee cups of coffee and $pancakes pancakes, please.&quot;</span>)
           <span class="kw">end</span>
    breakfast (generic <span class="kw">function</span> with <span class="fl">1</span> method)
    
    julia&gt; breakfast(<span class="fl">2</span>,<span class="fl">4</span>)
    <span class="fl">4</span> cups of coffee and <span class="fl">2</span> pancakes, please.</code></pre>
<h4 id="return-values">Return values</h4>
<p>In general, Julia returns the last value to come from the last calculation within the block:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="kw">function</span> dinner(sausages, mash)
               cost_of_sausages = sausages * <span class="fl">0.85</span>
               cost_of_mash = (mash == true ? <span class="fl">0.60</span> : <span class="fl">0.00</span>)
               cost_of_sausages + cost_of_mash
           <span class="kw">end</span>
    dinner (generic <span class="kw">function</span> with <span class="fl">1</span> method)
    
    julia&gt; dinner(<span class="fl">2</span>, true)
    <span class="fl">2.3</span></code></pre>
<p>While we haven’t told Julia what we exactly want the function to return, it infers that it would probably be the result of the last calculation (<code>cost_of_sausages + cost_of_mash</code>).</p>
<p>Now imagine that the fictitious canteen, who are so keen on calculating the cost of sausages and mash for dinner, get back to you and want the function to be changed. They are, it turns out, only interested in the cost of sausages. You could simply put <code>cost_of_sausages</code> to the very end of the function, before the <code>end</code> keyword, or you could use the <code>return</code> keyword, which will tell the function what to give back. Let’s redefine <code>dinner(sausages, mash)</code> to fit the canteen’s expectations using the <code>return</code> keyword:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="kw">function</span> dinner(sausages, mash)
               cost_of_sausages = sausages * <span class="fl">0.85</span>
               cost_of_mash = (mash == true ? <span class="fl">0.60</span> : <span class="fl">0.00</span>)
               <span class="kw">return</span> cost_of_sausages
           <span class="kw">end</span>
    dinner (generic <span class="kw">function</span> with <span class="fl">1</span> method)
    
    julia&gt; dinner(<span class="fl">2</span>, true)
    <span class="fl">1.7</span></code></pre>
<p>As a matter of style, <code>return</code> is a good idea to use, even if the function would return the right value. Whoever ends up debugging the script will be grateful you told them what exactly a function ends up returning.</p>
<h3 id="variable-numbers-of-positional-arguments-...-splats">Variable numbers of positional arguments: <code>...</code> (‘splats’)</h3>
<p>The above simple function had a definite number of arguments that had to be in a particular order. Arguments where the identity of the particular argument is determined by its position among the arguments are called <em>positional arguments</em> – so in the example above, Julia knew the argument <code>2</code> related to <code>sausages</code>, not <code>mash, because that's the position in which it was defined. But what if you don't know how many inputs you are likely to get for a particular function? Let us imagine a function, called</code>shout()`, that shouts the patrons’ orders back to the short-order cook. Some customers want a long list of items, others just one or two.</p>
<p>One way to implement this is to expect an array argument:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> shout(food_array)
        food_items = join(food_array, <span class="st">&quot;, &quot;</span>, <span class="st">&quot; and &quot;</span>)
        println(<span class="st">&quot;Get this guy $food_items\!&quot;</span>)
    <span class="kw">end</span></code></pre>
<p>Invoking this with two arguments, we get</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; shout([<span class="st">&quot;some pancakes&quot;</span>, <span class="st">&quot;sausages with gravy&quot;</span>])
    Get this guy some pancakes and sausages with gravy!</code></pre>
<p>These are returned to the function as a tuple listing each element covered by the splats.</p>
<p>What, however, if someone has more of an appetite? Our <code>shout()</code> function can accommodate it - the array just needs to get larger. This approach is perfectly viable, but regarded as a bit clumsy. What if I forget the array square brackets, for instance?</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; shout(<span class="st">&quot;pancakes&quot;</span>)
    Get this guy p, a, n, c, a, k, e and s!</code></pre>
<p>Well, that’s not quite what I wanted! Fortunately, Julia allows us to have not merely multiple arguments but indeed an indefinite number. We effect this by suffixing the variable we wish to hold the positional arguments with three full stops <code>...</code>, also known as a ‘splat’:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> shout_mi(foods...)
        food_items = join(foods, <span class="st">&quot;, &quot;</span>, <span class="st">&quot; and &quot;</span>)
        println(<span class="st">&quot;Get this guy some $food_items\!&quot;</span>)
    <span class="kw">end</span></code></pre>
<p>Now our function performs perfectly, whether our customer is ravenous or he just wants some pancakes:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; shout_mi(<span class="st">&quot;pancakes&quot;</span>)
    Get this guy some pancakes!
    
    julia&gt; shout_mi(<span class="st">&quot;pancakes&quot;</span>, <span class="st">&quot;sausages&quot;</span>, <span class="st">&quot;gravy&quot;</span>, <span class="st">&quot;a milkshake&quot;</span>)
    Get this guy some pancakes, sausages, gravy and a milkshake!</code></pre>
<p>What, however, if our customer does not seem to say anything? We would expect this to raise an error… but it doesn’t:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; shout_mi()
    Get this guy some !</code></pre>
<p>Therefore, we need be mindful of using a splatted positional argument right in the beginning, since it will accept the input of, well, no input! A common way to fix this is to require one positional argument, then add a splatted second argument. This way, if the function is called with no arguments at all, it will raise an error. A better way, perhaps, is to simply test for it ourselves:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> bulletproof_shout(foods...)
        <span class="kw">if</span> length(foods) &gt; <span class="fl">0</span>
            println(<span class="st">&quot;Get this guy some $(join(foods, &quot;</span>, <span class="st">&quot;, &quot;</span> and <span class="st">&quot;))\!&quot;</span>)
        <span class="kw">else</span>
            error(<span class="st">&quot;The customer needs to order something!&quot;</span>)
        <span class="kw">end</span>
    <span class="kw">end</span></code></pre>
<p>As you recall, the <code>foods</code> variable is passed on to us as a tuple. We can use the <code>length()</code> function on this tuple (although do note, we do test explicitly for <code>length(foods) &gt; 0</code>: a result of zero would not be ‘falsey’, so testing simply for <code>if length(foods)</code> would not cut it!), which will indicate how many elements the tuple has and raise an error if it is zero:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; bulletproof_shout(<span class="st">&quot;sausages&quot;</span>, <span class="st">&quot;pancakes&quot;</span>, <span class="st">&quot;gravy&quot;</span>)
    Get this guy some sausages, pancakes and gravy!
    
    julia&gt; bulletproof_shout(<span class="st">&quot;sausages&quot;</span>)
    Get this guy some sausages!
    
    julia&gt; bulletproof_shout()
    ERROR: The customer needs to order something!
     <span class="kw">in</span> bulletproof_shout at none:<span class="fl">5</span></code></pre>
<p>Finally, the function works. The last marginal case that you might want to deal with is when the customer’s order consists of an empty string <code>&quot;&quot;</code> or is the wrong type. These are further marginal cases and will not be explored here (although we will be looking at user input in quite a bit of detail in the second part of the book). The take-away is this - a good function (one you would let your grandmother use) needs to cater for a range of marginal cases and inputs. Splats are, however, somewhat performance-consuming and are best avoided in code that needs to run fast. In such situations, usability and performance need to be weighed and balanced.</p>
<h3 id="optional-positional-arguments">Optional positional arguments</h3>
<p>Positional arguments may be ‘optional’. This does not mean they are not used - they are optional only from the user’s p] erspective, who will not be required to enter them. A perhaps better way to put this is that these arguments have <em>default values</em> that take effect if they are not provided at invocation. Consider the following function, which accepts 2D as well as 3D coordinates, and sets 2D coordinates, by default, on the <code>z = 0</code> plane:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> coords(x, y, z = <span class="fl">0</span>)
        <span class="kw">return</span>(x,y,z)
    <span class="kw">end</span></code></pre>
<p>The result:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; coords(<span class="fl">1</span>, <span class="fl">6</span>, <span class="fl">7</span>)
    (<span class="fl">1</span>,<span class="fl">6</span>,<span class="fl">7</span>)
    
    julia&gt; coords(<span class="fl">3</span>, <span class="fl">1</span>)
    (<span class="fl">3</span>,<span class="fl">1</span>,<span class="fl">0</span>)</code></pre>
<p>Setting defaults allows you to prevent the inevitable error that would be triggered if <code>z = 0</code> were not provided for. Consider, for instance, what would happen if the value for <code>y</code>, for which no default value has been set, were to be missing:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; coords(<span class="fl">3</span>)
    ERROR: `coords` has no method matching coords(::<span class="dt">Int64</span>)</code></pre>
<p>Julia is telling us, in its somewhat odd grammar, that the function <code>coords()</code> is not defined for a single input.</p>
<h3 id="keyword-arguments">Keyword arguments</h3>
<p>The drawback of positional arguments is that getting the order right can be an inconvenience. Wouldn’t it be much easier, not the least from a documentation perspective, if we were allowed to give arguments names and use these names at invocation? With Julia, you can do so at your heart’s content, as long as you put them at the end of your variables when defining the function and delimit keyword arguments from non-keyword arguments with a semicolon <code>;</code>, as in this snippet:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> buzzphrase(verb, adjective; subject=<span class="st">&quot;defence&quot;</span>, goal=<span class="st">&quot;world peace&quot;</span>)
        println(<span class="st">&quot;$(verb)ing $adjective $subject for $goal.&quot;</span>)
    <span class="kw">end</span></code></pre>
<p>In this function, <code>verb</code> and <code>adjective</code> are necessary positional arguments. However, you can use the keyword argument syntax for <code>subject</code> and <code>goal</code>. As you can see, both have defined default values – this is necessary for keyword arguments in Julia. Thus,</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    buzzphrase(<span class="st">&quot;leverag&quot;</span>, <span class="st">&quot;effective&quot;</span>, subject=<span class="st">&quot;best practices&quot;</span>, goal=<span class="st">&quot;increased margins&quot;</span>)</code></pre>
<p>is equivalent to</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    buzzphrase(<span class="st">&quot;leverag&quot;</span>, <span class="st">&quot;effective&quot;</span>, goal=<span class="st">&quot;increased margins&quot;</span>, subject=<span class="st">&quot;best practices&quot;</span>)</code></pre>
<p>and yield the same results.</p>
<h3 id="stabby-lambda-functions--">Stabby lambda functions: <code>-&gt;</code></h3>
<p>Sometimes, you’re in a hurry and need a throwaway function. Whether it’s for <code>map</code>ping an Array or comparing values in a sort, sometimes you don’t want to define a function. A number of languages refer to these as <em>anonymous functions</em>, because they do not have a defined name, or reserve a <code>lambda</code> keyword for this, harkening back to Alonzo Church’s ‘lambda calculus’ well before the advent of modern computers. Julia has a stylised arrow <code>-&gt;</code>, leading to the name <em>stabby lambda</em> for such functions.</p>
<p>Assume you want to <code>map</code> the array of all primes under 10 <code>[2,3,5,7]</code> to a function <code>f</code> so that <code>f(x) = 2x^3 + x^2 - 2x + 4</code>. In case you’re unfamiliar with <code>map()</code> functions, here’s the elevator pitch: map functions take a function and an iterable and return an iterable of equal length, each element of which will be the result of feeding an element of the original iterable into the function. In Julia, <code>map()</code> takes two arguments - a function and an iterable. For the former, you can use a function defined in advance or use the stabby lambda notation that is the subject of this section.</p>
<p>The mapping function would be written in the stabby lambda notation as</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    x -&gt; <span class="fl">2</span>x^<span class="fl">3</span> + x^<span class="fl">2</span> - <span class="fl">2</span>x + <span class="fl">4</span></code></pre>
<p>somewhat similar to the maplet notation in mathematics. Thus, we would use the <code>map</code> function as follows:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; map(x -&gt; <span class="fl">2</span>x^<span class="fl">3</span> + x^<span class="fl">2</span> - <span class="fl">2</span>x + <span class="fl">4</span>, [<span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">5</span>, <span class="fl">7</span>])
    <span class="fl">4</span>-element <span class="dt">Array</span>{<span class="dt">Int64</span>,<span class="fl">1</span>}:
      <span class="fl">20</span>
      <span class="fl">61</span>
     <span class="fl">269</span>
     <span class="fl">725</span></code></pre>
<p>The stabby lambda is a little controversial, being even <a href="http://julia.readthedocs.org/en/latest/manual/style-guide/#do-not-write-x-f-x">discouraged where it serves as a mere wrapper</a> by the official Julia Style Guide, for the reason that such functions are impossible to unit test and can make code confusing. In general, the advice that is often given to, and by, Python programmers about <code>lambda</code>s in Python holds for their stabby Julia equivalents: a stabby lambda should be <em>obviously and unambiguously true</em>, that is, it should be evident at first glance</p>
<ul>
<li>what it does,</li>
<li>how it does what it does, and</li>
<li>that it does what it’s supposed to do correctly.</li>
</ul>
<p>In other words, consider a stabby lambda a sort of ‘special pleading’ - you’re arguing that the function is so trivially true, defining it in a long and extensive way would benefit the code less than what is gained by the brevity of the stabby lambda syntax.</p>
<h3 id="do-blocks"><code>do</code> blocks</h3>
<p><code>do</code> blocks are another form of anonymous functions. Similarly to stabby lambdas, they introduce a functional process that doesn’t need to be defined by name. Let’s consider the stabby lambda in the previous example and try to rewrite it as a <code>do</code> block:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    map([<span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">5</span>, <span class="fl">7</span>]) <span class="kw">do</span> x
        <span class="fl">2</span>x^<span class="fl">3</span> + x^<span class="fl">2</span> - <span class="fl">2</span>x + <span class="fl">4</span>
    <span class="kw">end</span></code></pre>
<p>The <code>do</code> block is a bit of syntactic sugar that helps us avoid unduly long stabby lambdas, as well as do slightly more complex things that the stabby lambda’s restricted format might not allow for, such as more complex testing than a stabby lambda coupled with a ternary operator would allow:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    map([<span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">5</span>, <span class="fl">7</span>]) <span class="kw">do</span> x
        <span class="kw">if</span> mod(x, <span class="fl">3</span>) == <span class="fl">0</span>
            x^<span class="fl">2</span> + <span class="fl">2</span>x - <span class="fl">4</span>
        <span class="kw">elseif</span> mod(x, <span class="fl">3</span>) == <span class="fl">1</span>
            <span class="fl">2</span>x^<span class="fl">3</span> + x^<span class="fl">2</span> - <span class="fl">2</span>x + <span class="fl">4</span>
        <span class="kw">else</span>
            <span class="fl">2</span>x-<span class="fl">4</span>
        <span class="kw">end</span>
    <span class="kw">end</span></code></pre>
<h3 id="returning-multiple-values">Returning multiple values</h3>
<p>A function needs to return a single object, but that object may take the shape of a collection containing multiple values. If your function does return multiple values from within the function, they will be returned as a tuple:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="kw">function</span> squares(x, y)
               <span class="kw">return</span> x^<span class="fl">2</span>, y^<span class="fl">2</span>
           <span class="kw">end</span>
    squares (generic <span class="kw">function</span> with <span class="fl">1</span> method)
    
    julia&gt; squares(<span class="fl">2</span>,<span class="fl">5</span>)
    (<span class="fl">4</span>,<span class="fl">25</span>)
    
    julia&gt; typeof(squares(<span class="fl">2</span>,<span class="fl">5</span>))
    (<span class="dt">Int64</span>,<span class="dt">Int64</span>)</code></pre>
<p>As we can see, the function returned two values of type <code>Int64</code>, in a tuple. For various reasons, you may prefer defining your own type to return, such as a composite type - this is up to you and Julia gives you considerable freedom in doing so.</p>
<h3 id="scope-in-function-evaluation">Scope in function evaluation</h3>
<p><em>Scope</em> in function evaluation refers to the availability of variables within or outside a function. Much of what has been said about scope in blocks in general applies here, but function evaluation has some peculiar quirks that are worth mentioning.</p>
<h4 id="lexical-scoping">Lexical scoping</h4>
<p>Julia implements <em>lexical scoping</em>, that is, the scope of a function is inherited not from its caller but its definition. Consider the following:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> foo()
        println(x)
    <span class="kw">end</span>
    
    <span class="kw">function</span> bar()
        x = <span class="fl">2</span>
        foo()
    <span class="kw">end</span>
    
    julia&gt; bar()
    ERROR: x not defined
     <span class="kw">in</span> bar at none:<span class="fl">3</span></code></pre>
<p>This is not unexpected, since the assignment of <code>x</code> to 2 is ‘not visible’ to the function <code>foo</code> when it’s called. In other words, the assignment of <code>x</code> is <em>outside the scope</em> of the function. Therefore, it does not <code>see</code> the variable’s definition and this yields an undefined variable error.</p>
<h4 id="global-variables">Global variables</h4>
<p>A variable defined in the global scope is available to all functions:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; x = <span class="fl">2</span>
    <span class="fl">2</span>
    
    julia&gt; foo()
    <span class="fl">2</span></code></pre>
<p>While this is very helpful, global variables incur an immense performance penalty. Their use is generally discouraged unless absolutely necessary.</p>
<h2 id="higher-order-functions">Higher order functions</h2>
<p>In general, the idea of a <em>higher order function</em> serves to distinguish functions that accept a function as an argument from other functions, sometimes referred to as <em>first-order functions</em>. In functional programming, higher order functions are much more important than in OOP or other paradigms, and indeed even if you return to your OOP roots, an understanding of higher order functions will help you enormously in dealing with the implementations of higher order functions in your language of choice: since most higher-order functions are so useful for munging data, most programming languages do have implementations of <code>map()</code>, <code>sort()</code> and other archetypal higher order functions.</p>
<h3 id="functions-that-accept-functions-as-arguments">Functions that accept functions as arguments</h3>
<p>We have already introduced <code>map()</code>, a typical higher-order function, above. While higher-order functions appear to be somewhat complex, they are actually easier than they seem. A function is an object like any other, and so can be fed into another function as an argument. You will not, generally, need to do anything special for your function to accept a function as an argument, except make sure you are calling the function provided to you.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> greet(x)
        str = x()
        println(<span class="st">&quot;Hello, $str\!&quot;</span>)
    <span class="kw">end</span>
    
    <span class="kw">function</span> tell_me_where_I_live()
        <span class="kw">return</span>(<span class="st">&quot;world&quot;</span>)
    <span class="kw">end</span>
    
    julia&gt; greet(tell_me_where_I_live)
    Hello, world!</code></pre>
<p>Quite importantly, when you are passing a function to another function as an argument, <em>you are not passing a call, you’re passing the function object</em> - so don’t forget to skip the parentheses <code>()</code>!</p>
<h4 id="operators-and-higher-order-functions">Operators and higher-order functions</h4>
<p>Operators, such as <code>+</code>, are just clever aliases for functions. Thus, there is no reason why they couldn’t be passed into a function:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> oper(x, y, z)
        <span class="kw">return</span> x(y, z)
    <span class="kw">end</span>
    
    julia&gt; oper(+, π, e)
    <span class="fl">5.859874482048838</span></code></pre>
<p>In this case, the operator <code>+</code> was fed into our function (which did nothing but execute the operator fed in as <code>x</code> on <code>y</code> and <code>z</code>).</p>
<h3 id="functions-that-return-functions">Functions that return functions</h3>
<p>Just as accepting functions is perfectly permissible, a function can return a function as a result. Consider a function that returns an exponential function based on your input as the exponent.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> create_exponential_function(exponent)
        exp_func = <span class="kw">function</span>(x)
            <span class="kw">return</span> x^exponent
        <span class="kw">end</span>
        <span class="kw">return</span> exp_func
    <span class="kw">end</span>
    
    julia&gt; power_of_five = create_exponential_function(<span class="fl">5</span>)
    (anonymous <span class="kw">function</span>)
    
    julia&gt; power_of_five(<span class="fl">5</span>)
    <span class="fl">3125</span></code></pre>
<p>The function above can be written more concisely with the stabby lambda syntax we encountered earlier:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> create_exponential_function(exponent)
        y -&gt;  y^exponent
    <span class="kw">end</span></code></pre>
<h3 id="currying">Currying</h3>
<p>Some languages, including some functional languages, support a feature called <em>currying</em>, named not after the Indian spice but after logician Haskell Curry (namesake of the <code>Haskell</code> language). A curried function is one that has multiple arguments. If it is provided with values for all of them, it returns a value. If it is provided with only part of them, it returns a function that takes the missing values as arguments.</p>
<p>Currying was <a href="https://github.com/JuliaLang/julia/issues/554">proposed</a> for Julia in 2012, but voted down, not least because it would have been difficult to accommodate within multiple dispatch.</p>
<h2 id="methods-and-multiple-dispatch">Methods and multiple dispatch</h2>
<h3 id="understanding-multiple-dispatch">Understanding multiple dispatch</h3>
<p>When you call a function on a number of arguments, Julia needs to decide how exactly that function makes sense for those arguments. In this sense, functions are not so much names for individual functions but for bunches of conceptually similar functions, with Julia deciding which particular one to call. Consider the <code>*</code> operator (which, like all operators, is a function):</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; π * e
    <span class="fl">8.539734222673566</span>
    
    julia&gt; <span class="st">&quot;sausages &quot;</span> * <span class="st">&quot;mash&quot;</span>
    <span class="st">&quot;sausages mash&quot;</span></code></pre>
<p>As the example above shows, the <code>*</code> function can take various types, and it has various actions defined for each - for numeric types, this involves multiplication, while for strings, <code>*</code> means concatenation. The feature of Julia that allows the call of the right implementation of a function based on arguments is called <em>multiple dispatch</em>, and the implementations are referred to as <em>methods</em>. Each function may have a number of methods defined for various data types, and it may have no methods at all defined for some. Finally, the error message we get when we use the ‘wrong’ type of input starts to make sense:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; <span class="fl">2</span> * <span class="st">&quot;sausage&quot;</span>
    ERROR: `*` has no method matching *(::<span class="dt">Int64</span>, ::<span class="dt">ASCIIString</span>)
    Closest candidates are:
      *(::<span class="dt">Number</span>, ::<span class="dt">Bool</span>)
      *(::<span class="dt">Int64</span>, ::<span class="dt">Int64</span>)
      *(::<span class="dt">Real</span>, ::<span class="dt">Complex</span>{T&lt;:<span class="dt">Real</span>})
      ...</code></pre>
<p>What Julia is referring to in this instance is that <code>*</code> is not defined for one <code>Int64</code> and one <code>ASCIIString</code> operator. In other words, the function <code>*</code> has no method defined that would take these two particular kinds, after which it then recommends various options (some fairly unexpected, for instance, <code>::Number</code> * <code>::Bool</code> is perfectly valid – it multiplies the <code>::Number</code> by 1 if the <code>::Bool</code> is <code>true</code> and 0 if it is <code>false</code>).</p>
<h3 id="building-methods">Building methods</h3>
<p>To construct a method, you can simply declare the function for a particular data type. Let’s consider a function that adds numbers and concatenates strings (for now, only two of each - the function can be expanded using the splat <code>...</code> syntax easily).</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> merge_together(a::<span class="dt">Number</span>, b::<span class="dt">Number</span>)
        a + b
    <span class="kw">end</span></code></pre>
<p>This is great. It does a great job at adding up numbers:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; merge_together(<span class="fl">2</span>, π)
    <span class="fl">5.141592653589793</span></code></pre>
<p>It’s less adept at doing the string concatenation part we need it to do:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; merge_together(<span class="st">&quot;Sausages with&quot;</span>, <span class="st">&quot; mash&quot;</span>)
    ERROR: `merge_together` has no method matching merge_together(::<span class="dt">ASCIIString</span>, ::<span class="dt">ASCIIString</span>)</code></pre>
<p>Therefore, we will need to define a method for <code>merge_together()</code> that will accept <code>ASCIIString</code> arguments. When Julia tells us a method is missing, it will give us the concrete data type of the argument we have entered. This is useful, but try to resist the temptation to define <code>merge_together</code> for <code>::ASCIIString</code>. In general, if your use case relates not to the concrete type but to the broader, <em>abstract</em> type (such as ours, where our use case is really <em>all</em> strings, not just <code>ASCIIString</code>), it’s good practice to use the broadest abstract type that will include only the data types that you need. In this case, it is not <code>ASCIIString</code> but its abstract ancestor, <code>AbstractString</code> (in case you forgot your handy inheritance dendrogram, you can look at the supertype of any type by using <code>super(ASCIIString)</code> with the name of the type you’re interested in). Let’s define <code>merge_together</code> for two <code>::AbstractString</code> objects:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> merge_together(a::AbstractString, b::AbstractString)
        a * b
    <span class="kw">end</span></code></pre>
<p>That’s it, folks! Julia helpfully tells us that <code>merge_together</code> now has two methods. Using <code>methods(merge_together)</code>, we can list these:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; methods(merge_together)
    <span class="co"># 2 methods for generic function &quot;merge_together&quot;:</span>
    merge_together(a::<span class="dt">Number</span>,b::<span class="dt">Number</span>) at none:<span class="fl">2</span>
    merge_together(a::AbstractString,b::AbstractString) at none:<span class="fl">2</span></code></pre>
<p>Let’s give the second one, for strings, a try:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; merge_together(<span class="st">&quot;Sausages with&quot;</span>, <span class="st">&quot; mash&quot;</span>)
    <span class="st">&quot;Sausages with mash&quot;</span></code></pre>
<p>It works! In general, when creating a function, you need to be circumspect as to what you want to use it for and what it needs to be able to deal with. There is no need for a function to have methods for all data types. So far, we have generally not defined the data types of arguments. This is a bad practice, and when you are building functions, you should always think of yourself as building methods at the same time, and define the types you want your function to accept.</p>
<h3 id="call-order-and-method-ambiguities">Call order and method ambiguities</h3>
<p>Consider the following function <code>f</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> f(x)
        <span class="kw">return</span> x
    <span class="kw">end</span>
    
    <span class="kw">function</span> f(x::<span class="dt">Int</span>)
        <span class="kw">return</span> x^<span class="fl">2</span>
    <span class="kw">end</span></code></pre>
<p>The first definition, lacking a type restriction, is deemed by Julia to accept inputs of type <code>Any</code> - that is, any type. The second method, however, only takes inputs of type <code>Int</code>. As such, it is more specific (or, if you please, ‘further downstream on the type dendrogram’). The result is that when you call <code>f(2)</code>, the second, more specific method will be called, even if technically, the argument <code>2</code> would be acceptable for both. This is a sensible approach, since the broader the type, the more likely that the method is intended to be a ‘catch-all’ to mop up cases that have not been caught by any of the subtypes.</p>
<p>However, for functions with multiple arguments, it is possible that there is no unique method that is more unambiguous than the others. Consider the following:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> g(x::<span class="dt">Int</span>, y)
        <span class="kw">return</span> <span class="fl">2</span>x^<span class="fl">2</span> - <span class="fl">2</span>y
    <span class="kw">end</span>
    
    <span class="kw">function</span> g(x, y::<span class="dt">Int</span>)
        <span class="kw">return</span> <span class="fl">2</span>x - <span class="fl">2</span>y^<span class="fl">2</span>
    <span class="kw">end</span></code></pre>
<p>Which of these functions is ‘more definite’ when called as, say, <code>g(6, 8)</code>? The answer is ‘neither’, and Julia says so much when declaring the second method:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    Warning: New definition
        g(<span class="dt">Any</span>,<span class="dt">Int64</span>) at none:<span class="fl">2</span>
    is ambiguous with:
        g(<span class="dt">Int64</span>,<span class="dt">Any</span>) at none:<span class="fl">2</span>.
    To fix, define
        g(<span class="dt">Int64</span>,<span class="dt">Int64</span>)
    before the new definition.
    g (generic <span class="kw">function</span> with <span class="fl">2</span> methods)</code></pre>
<p>A method <code>g(x::Int64, y::Int64)</code> will be more specific than either of the previously defined methods, and as such capable of dealing with the indefinite middle.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> g(x::<span class="dt">Int</span>, y::<span class="dt">Int</span>)
        <span class="kw">return</span> x^<span class="fl">2</span> - y^<span class="fl">2</span>
    <span class="kw">end</span></code></pre>
<h3 id="parametric-methods">Parametric methods</h3>
<p>A parametric method, similar to parametric types, is one in which a logical relationship is asserted between types, rather than an actual type name. You may think of parameters as ‘variables’ for type assertions. The parameter - by convention, but not by necessity, <code>T</code> for type - is enclosed in curly braces <code>{}</code> and interposed between the function name and its arguments:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> identical_types{T}(x::T, y::T)
        ...
    <span class="kw">end</span></code></pre>
<p>This function would accept arguments of the same type, regardless of what that type is. You can restrict the possible values <code>T</code> might take based on type hierarchy:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> identical_numbers{T&lt;:<span class="dt">Number</span>}(x::T, y::T)
        ...
    <span class="kw">end</span></code></pre>
<p>This function allows for any inputs that are both identical <em>and</em> descendants of the <code>Number</code> supertype. Contrast that with</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> divergent_numbers(x::<span class="dt">Number</span>, y::<span class="dt">Number</span>)
        ...
    <span class="kw">end</span></code></pre>
<p>which accepts inputs that are descendants of the <code>Number</code> supertype, regardless of whether their type matches or not.</p>
<h3 id="inspecting-methods">Inspecting methods</h3>
<p>Entering a function object into the REPL, but not calling the function object, will indicate the number of methods under the function:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; +
    + (generic <span class="kw">function</span> with <span class="fl">150</span> methods)</code></pre>
<p>You can inspect methods available under a function by using the <code>method()</code> command and passing the function or operator as argument:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; methods(+)
    <span class="co"># 150 methods for generic function &quot;+&quot;:</span>
    +(x::<span class="dt">Bool</span>) at bool.jl:<span class="fl">34</span>
    +(x::<span class="dt">Bool</span>,y::<span class="dt">Bool</span>) at bool.jl:<span class="fl">37</span>
    ...
    +(a,b,c) at operators.jl:<span class="fl">83</span>
    +(a,b,c,xs...) at operators.jl:<span class="fl">84</span></code></pre>
<h1 id="chapter-8-handling-errors">Chapter 8: Handling errors</h1>
<p>Error (or exception) handling is an essential feature of writing all but trivial programs. Let’s face it – s**t happens, and sometimes the best-written programs encounter errors. Well-written code handles errors gracefully and as early as possible.</p>
<p>Over the years, two main ‘approaches’ to error handling have emerged. Those advocating the <strong>LBYL</strong> approach (<strong>L</strong>ook <strong>b</strong>efore <strong>y</strong>ou <strong>l</strong>eap) support validating every of data well before they are used and only use data that has passed the test. LBYL code is lengthy, and looks very solid. In recent years, an approach known as <strong>EAFP</strong> has emerged, asserting the old Marine Corps motto that it is <strong>e</strong>asier to <strong>a</strong>sk <strong>f</strong>orgiveness than <strong>p</strong>ermission. EAFP code relies heavily on exception handling and <code>try</code>/<code>catch</code> constructs to deal with the occasional consequences of having leapt before looking. While EAFP is generally regarded with more favour in recent years than LBYL, especially in the Python community, which all but adopted it as its official mantra, both approaches have merits (and serious drawbacks). Julia is particularly suited to an amalgam of the two methods, so whichever of them suits you, your coding style and your use case more, you will find Julia remarkably accommodating.</p>
<h2 id="creating-and-raising-exceptions">Creating and raising exceptions</h2>
<p>Julia has a number of built-in exception types, each of which can be thrown when unexpected conditions occur.</p>
<p><TODO: Table of exceptions and their meanings></p>
<p>Note that these are exception types, rather than particular exceptions, therefore despite their un-function-like appearance, they will need to be called, using parentheses.</p>
<h3 id="throwing-exceptions">Throwing exceptions</h3>
<p>The <code>throw</code> function allows you to raise an exception:</p>
<pre><code>if circumference &gt; 0
    circumference/2π
elseif circumference == 0
    throw(DivideError())
else
    throw(DomainError())
end</code></pre>
<p>As noted above, exception types need to be called to get an <code>Exception</code> object. Hence, <code>throw(DomainError)</code> would be incorrect.</p>
<p>In addition, some exceptions take arguments that elucidate upon the error at hand. Thus, for instance, <code>UndefVarError</code> takes a symbol as an argument, referring to the symbol invoked without being defined:</p>
<pre><code>julia&gt; throw(UndefVarError(thisvariabledoesnotexist))
ERROR: thisvariabledoesnotexist not defined</code></pre>
<h3 id="throwing-a-generic-errorexception">Throwing a generic <code>ErrorException</code></h3>
<p>The <code>error</code> function throws a generic <code>ErrorException</code>. This will interrupt execution of the function or block immediately. Consider the following example, courtesy of Julia’s <a href="http://docs.julialang.org/en/latest/manual/control-flow/#errors">official documentation</a>. First, we define a function <code>fussy_sqrt</code> that raises an <code>ErrorException</code> using the function <code>error</code> if <code>x &lt; 0</code>:</p>
<pre><code>julia&gt; fussy_sqrt(x) = x &gt;= 0 ? sqrt(x) : error(&quot;negative x not allowed&quot;)</code></pre>
<p>Then, the following verbose wrapper is created:</p>
<pre><code>julia&gt; function verbose_fussy_sqrt(x)
         println(&quot;before fussy_sqrt&quot;)
         r = fussy_sqrt(x)
         println(&quot;after fussy_sqrt&quot;)
         return r
       end
verbose_fussy_sqrt (generic function with 1 method)</code></pre>
<p>Now, if <code>fussy_sqrt</code> encounters an argument <code>x &lt; 0</code>, an error is raised and execution is aborted. In that case, the second message (<code>after fussy_sqrt</code>) would never come to be displayed:</p>
<pre><code>julia&gt; verbose_fussy_sqrt(2)
before fussy_sqrt
after fussy_sqrt
1.4142135623730951

julia&gt; verbose_fussy_sqrt(-1)
before fussy_sqrt
ERROR: negative x not allowed
 in verbose_fussy_sqrt at none:3</code></pre>
<h3 id="creating-your-own-exceptions">Creating your own exceptions</h3>
<p>You can create your own custom exception that inherits from the superclass <code>Exception</code> by</p>
<pre><code>type MyException &lt;: Exception 
end</code></pre>
<p>If you wish your exception to take arguments, which can be useful in returning a useful error message, you will need to amend the above data type to include fields for the the arguments, then create a method under <code>Base.showerror</code> that implements the error message:</p>
<pre><code>type MyExceptionTree &lt;: Exception
    var::String
end

Base.showerror(io::IO, e::MyExceptionTree) = print(io, &quot;Something is wrong with &quot;, e.var, &quot;!&quot;)

julia&gt; throw(MyException(&quot;this code&quot;))
ERROR: Something is wrong with this code.</code></pre>
<h2 id="handling-exceptions">Handling exceptions</h2>
<h3 id="the-trycatch-structure">The <code>try</code>/<code>catch</code> structure</h3>
<p>Using the keywords <code>try</code> and <code>catch</code>, you can handle exceptions, both generally and dependent on a variable. The general structure of <code>try</code>/<code>catch</code> is as follows:</p>
<ol style="list-style-type: decimal">
<li><strong><code>try</code> block</strong>: This is where you would normally introduce the main body of your function. Julia will attempt to execute the code within this section.</li>
<li><strong><code>catch</code></strong>: The <code>catch</code> keyword, on its own, catches all errors. It is helpful to instead use it with a variable, to which the exception will be assigned, e.g. <code>catch err</code>.</li>
<li>If the exception was assigned to a variable, <strong>testing for the exception</strong>: using <code>if</code>/<code>elseif</code>/<code>else</code> structures, you can test for the exception and provide ways to handle it. Usually, type assertions for errors will use <code>isa(err, ErrorType)</code>, which will return true if <code>err</code> is an instance of the error type <code>ErrorType</code> (i.e. if it has been called by <code>ErrorType()</code>).</li>
<li><code>end</code> all blocks.</li>
</ol>
<p>This structure is demonstrated by the following function, creating a resilient, non-fussy <code>sqrt()</code> implementation that returns the complex square root of negative inputs using the <code>catch</code> syntax:</p>
<pre><code>function resilient_square_root(x::Number)
    try
        sqrt(x)
    catch err
        if isa(err, DomainError)
            sqrt(complex(x))
        end
    end
end</code></pre>
<p>There is no need to specify a variable to hold the error instance. Similarly to not testing for the identity of the error, such a clause would result in a catch-all sequence. This is not necessarily a bad thing, but good code is responsive to the nature of errors, rather than their mere existence, and good programmers would always be interested in <em>why</em> their code doesn’t work, not merely in the fact that it failed to execute. Therefore, good code would check for the types of exceptions and only use catch-alls sparingly.</p>
<h4 id="one-line-trycatch">One-line <code>try</code>/<code>catch</code></h4>
<p>If you are an aficionado of brevity, you should be careful when trying to put a <code>try</code>/<code>catch</code> expression. Consider the following code:</p>
<pre><code>try sqrt(x) catch y end</code></pre>
<p>To Julia, this means <code>try sqrt(x)</code>, and if an exception is raised, pass it onto the variable <code>y</code>, when what you probably meant is <code>return y</code>. For that, you would need to separate <code>y</code> from the <code>catch</code> keyword using a semicolon:</p>
<pre><code>try sqrt(x) catch; y end</code></pre>
<h4 id="finally-clauses"><code>finally</code> clauses</h4>
<p>Once the <code>try</code>/<code>catch</code> loops have finished, Julia allows you to execute code that has to be executed whether the operation has succeeded or not. <code>finally</code> executes whether there was an exception or not. This is important for ‘teardown’ tasks, gracefully closing files and dealing with other stateful elements and resources that need to be closed whether there was an exception or not.</p>
<p>Consider the following example from the <a href="http://docs.julialang.org/en/latest/manual/control-flow/#finally-clauses">Julia documentation</a>, which involves opening a file, something we have not dealt with yet explicitly. <code>open(&quot;file&quot;)</code> opens a file in path <code>file</code>, and assigns it to an object, <code>f</code>. It then tries to operate on <code>f</code>. Whether those operations are successful or not, the file will need to be closed. <code>finally</code> allows for the execution of <code>close(f)</code>, closing down the file, regardless of whether an exception was raised in the code in the <code>try</code> section:</p>
<pre><code>f = open(&quot;file&quot;)
try
    # operate on file f
finally
    close(f)
end</code></pre>
<p>It’s good practice to ensure that teardown operations are executed regardless of whether the actual main operation has been successful, and <code>finally</code> is a great way to achieve this end.</p>
<h2 id="advanced-error-handling">Advanced error handling</h2>
<h3 id="info-and-warn"><code>info</code> and <code>warn</code></h3>
<p>We have seen that calling <code>error</code> will interrupt execution. What, however, if we just want to display a warning or an informational message without interrupting execution, as is common in debugging code? Julia provides the <code>info</code> and <code>warn</code> functions, which allow for the display of notifications without raising an interrupt:</p>
<pre><code>julia&gt; info(&quot;This code is looking pretty good.&quot;)
INFO: This code is looking pretty good.

julia&gt; warn(&quot;You&#39;re not looking too good. Best check yourself.&quot;)
WARNING: You&#39;re not looking too good. Best check yourself.</code></pre>
<h3 id="rethrow-backtrace-and-catch_backtrace"><code>rethrow</code>, <code>backtrace</code> and <code>catch_backtrace</code></h3>
<p>Julia provides three functions that allow you to delve deeper into the errors raised by an operation.</p>
<ul>
<li><code>rethrow</code>, as the name suggests, raises the last raised error again,</li>
<li><code>backtrace</code> executes a stack trace at the current point, and</li>
<li><code>catch_backtrace</code> gives you a stack trace of the last caught error.</li>
</ul>
<p>Consider our resilient square root function from the listing above. Using <code>rethrow()</code>, we can see exceptions that have been handled by the function itself:</p>
<pre><code>julia&gt; resilient_square_root(-2.345)
0.0 + 1.5313392831113555im

julia&gt; rethrow()
ERROR: DomainError
 in resilient_square_root at none:3</code></pre>
<p>As it’s evident from this example, <code>rethrow()</code> does not require the error to be actually one that is <code>throw</code>n - if the error itself is handled, it will still be retrieved by <code>rethrow()</code>.</p>
<p><code>backtrace</code> and <code>catch_backtrace</code> are functions that return stack traces at the time of call and at the last caught exception, respectively:</p>
<pre><code>julia&gt; resilient_square_root(-4)
0.0 + 2.0im

julia&gt; x^2 - 2x + 3
11

julia&gt; backtrace()
13-element Array{Ptr{Void},1}:
 Ptr{Void} @0x00000001013cbfae
 Ptr{Void} @0x000000010349ec30
 Ptr{Void} @0x000000010349ebb0
 Ptr{Void} @0x00000001013776e8
 Ptr{Void} @0x00000001013c6982
 Ptr{Void} @0x00000001013c5203
 Ptr{Void} @0x00000001013d4abd
 Ptr{Void} @0x000000010137cdfd
 Ptr{Void} @0x0000000103455c41
 Ptr{Void} @0x0000000103455747
 Ptr{Void} @0x00000001013776e8
 Ptr{Void} @0x0000000103451cca
 Ptr{Void} @0x00000001013cccc8
 
julia&gt; catch_backtrace()
14-element Array{Ptr{Void},1}:
 Ptr{Void} @0x00000001013cc506
 Ptr{Void} @0x00000001013cc5a9
 Ptr{Void} @0x00000001034a58e7
 Ptr{Void} @0x00000001034a56a7
 Ptr{Void} @0x00000001013776e8
 Ptr{Void} @0x00000001013c6982
 Ptr{Void} @0x00000001013c5203
 Ptr{Void} @0x00000001013d4abd
 Ptr{Void} @0x000000010137cdfd
 Ptr{Void} @0x0000000103455c41
 Ptr{Void} @0x0000000103455747
 Ptr{Void} @0x00000001013776e8
 Ptr{Void} @0x0000000103451cca
 Ptr{Void} @0x00000001013cccc8</code></pre>
<p>The first backtrace block shows the stack trace for the time after the function <code>x^2 - 2x + 3</code> has been executed. The second stacktrace, invoked by the <code>catch_backtrace()</code> call, shows the call stack as it was at the time of the <code>catch</code> in the <code>resilient_square_root</code> function. # Chapter 9: I/O</p>
<p>Interacting with real world data is where programming gets interesting. Mastering I/O opens up a world of information for your applications and is quite fun, too! With that, let’s delve into working with various file types.</p>
<h2 id="text-files">Text files</h2>
<h3 id="opening-and-closing-files">Opening and closing files</h3>
<p>In general, whenever you open a file, you will eventually need to close it. It’s quite crucial to be circumspect with these housekeeping duties, lest you end up with corrupted data!</p>
<p>Julia’s way of dealing with files resembles that of Python and a number of other languages. First, using the <code>open(path)</code> function, you open a file. The function returns an object that represents the file within Julia, known sometimes as a <em>file handle</em>. Commonly, the variable file handles are assigned to is <code>f</code>, but this does not have to be the case.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    f = open(<span class="st">&quot;textfile.txt&quot;</span>)</code></pre>
<p>When you’re done with your connection, use the <code>close()</code> function to close down the file handle:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    close(f)</code></pre>
<h3 id="reading-files">Reading files</h3>
<p>Creating a file handle does not actually read the file - it merely checks where it is and figures out how to deal with it. As such, creating your file handle is usually pretty quick and memory-inexpensive, even if the file itself is very large.</p>
<p>However, we want to get something out of the text we imported. For the rest of this chapter, I will be using Virgil’s Aeneid to demonstrate text functions, which you can obtain for yourself <a href="http://www.gutenberg.org/cache/epub/228/pg228.txt">here</a> courtesy of Project Gutenberg.</p>
<p>Once you have called the <code>open</code> function and assigned the file handle to <code>f</code>, you can start reading the file. Julia helpfully offers multiple ways to accomplish this, and it’s useful to remember the ability to read a large file line-by-line once we enter the realm of handling large data sets.</p>
<p>You might notice that using the read functions ‘uses up’ the file. This is true - once you have ‘read’ all lines, the file will be empty. This is handy for keeping track of how much has been already read and ensure that where a read process has been interrupted, you will know where to pick up the thread.</p>
<h4 id="readall"><code>readall</code></h4>
<p>The <code>readall</code> function allows you to read the entire file, which it contains in a massive string, with line breaks represented as newlines (<code>\n</code>):</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; readall(f)</code></pre>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; typeof(readall(f))
    <span class="dt">ASCIIString</span></code></pre>
<h4 id="readlines"><code>readlines</code></h4>
<p>Unlike <code>readall</code>, <code>readlines</code> creates an array of strings, each representing a line:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; readlines(f)
    <span class="fl">14656</span>-element <span class="dt">Array</span>{<span class="dt">Union</span>(<span class="dt">UTF8String</span>,<span class="dt">ASCIIString</span>),<span class="fl">1</span>}:
    <span class="st">&quot;\ufeff  Arms, and the man I sing, who, forc&#39;d by fate,</span>\r\n<span class="st">&quot;</span>
    <span class="st">&quot;  And haughty Juno&#39;s unrelenting hate,</span>\r\n<span class="st">&quot;</span>
    <span class="st">&quot;  Expell&#39;d and exil&#39;d, left the Trojan shore.</span>\r\n<span class="st">&quot;</span>
    <span class="st">&quot;  Long labors, both by sea and land, he bore,</span>\r\n<span class="st">&quot;</span>
    <span class="st">&quot;  And in the doubtful war, before he won</span>\r\n<span class="st">&quot;</span>
    <span class="st">&quot;  The Latian realm, and built the destin&#39;d town;</span>\r\n<span class="st">&quot;</span>
    <span class="st">&quot;  His banish&#39;d gods restor&#39;d to rites divine,</span>\r\n<span class="st">&quot;</span>
    <span class="st">&quot;  And settled sure succession in his line,</span>\r\n<span class="st">&quot;</span>
    <span class="st">&quot;  From whence the race of Alban fathers come,</span>\r\n<span class="st">&quot;</span>
    <span class="st">&quot;  And the long glories of majestic Rome.</span>\r\n<span class="st">&quot;</span></code></pre>
<p>You can technically iterate through it line by line, which is a useful function as it allows you to perform functions on smaller chunks of data.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    i = <span class="fl">1</span>
    <span class="kw">for</span> line <span class="kw">in</span> readlines(f)
        println(<span class="st">&quot;$i </span>\t<span class="st"> $line&quot;</span>)
        i += <span class="fl">1</span>
    <span class="kw">end</span></code></pre>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="fl">1</span>      Arms, and the man I sing, who, forc&#39;d by fate,
    
    <span class="fl">2</span>      And haughty Juno&#39;s unrelenting hate,
    
    <span class="fl">3</span>      Expell&#39;d and exil&#39;d, left the Trojan shore.</code></pre>
<p>However, Julia has something far better to accomplish that, as we’ll see in the next subsection.</p>
<h4 id="eachline"><code>eachline</code></h4>
<p><code>eachline</code> creates an iterator that you can use to go through and apply linewise functions. Let’s see how many characters are in each line:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">for</span> line <span class="kw">in</span> eachline(f)
        print(<span class="st">&quot;$(length(line)) </span>\t<span class="st"> $line&quot;</span>)
    <span class="kw">end</span></code></pre>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="fl">46</span>     Now, <span class="kw">in</span> clos&#39;d field, each other from afar
    <span class="fl">46</span>     They view; and, rushing on, <span class="kw">begin</span> the war.
    <span class="fl">58</span>     They launch their spears; then hand to hand they meet;
    <span class="fl">51</span>     The trembling soil resounds beneath their feet:
    <span class="fl">56</span>     Their bucklers clash; thick blows descend from high,
    <span class="fl">51</span>     And flakes of fire from their hard helmets fly.</code></pre>
<p>As we can see, the numbers are quite a bit off. This is ok - it’s due to the indentation and the rather archaic spelling. What matters is that we can execute a function on each line of the function.</p>
<h4 id="enumerate"><code>enumerate</code></h4>
<p><code>enumerate</code> is like a bonus function – it takes an iterable and creates an enumerator that also keeps track of</p>
<h1 id="chapter-7-writing-good-julia-functions">Chapter 7: Writing good Julia functions</h1>
<p>Writing good functions is not an art - it’s something you can learn with reasonably little practice. A good function, by our definition, is one that is</p>
<ul>
<li><em>performant</em>: it consumes as few resources as needed,</li>
<li><em>type-stable</em>: it always returns the same type of object, and</li>
<li><em>legible</em>: Julia is a fairly easy to read language, and so should your code be.</li>
</ul>
<p>These desiderata aren’t always compatible with each other, and it is your job as a programmer to figure out how to balance them, with their application in mind. The following therefore are not strict requirements, they are ways to accomplish each of the individual objectives.</p>
<h2 id="performant-code">Performant code</h2>
<p>Generally, the more complex an operation, the more the impact of performance optimisations is. The <code>O</code> (‘big O’) notation expresses this aptly. Consider two functions, one running at linear time <span class="math">\(O(n)\)</span> and one running at exponential time <span class="math">\(O(2^n)\)</span>. For a sufficiently small number of elements, the difference might not be visible. However, as the number of elements grows, the performance gaps are going to be huge, and well-written functions are the difference between a calculation taking minutes versus hours or even days.</p>
<h3 id="define-arguments-types-whenever-you-can-and-however-precisely-you-can">Define arguments’ types, whenever you can and however precisely you can</h3>
<p>When it comes to arguments, have a good think about what your function is supposed to do and what types it can, and what types it cannot, ingest. Planning first (or, <a href="http://programmers.stackexchange.com/questions/59152/code-documentation-first">according to some, even documenting first</a>) is a good idea - it will help you have an understanding of the needs of your code.</p>
<p>A functional programming language with multiple dispatch challenges you to <em>think in methods, not functions</em>. Create small, narrow methods that do something for particular and narrowly defined types, rather than broad functions. Especially to programmers coming from OOP thinking, the idea that functions are not atomic and actually break down into methods is difficult to digest. However, it’s worth the try - functions that Julia doesn’t have to ‘guess’ about evaluate much faster. Defining types precisely is also a sieve for incorrect input types. Programmers from other paradigms might be used to having to test whether inputs are the right format – in Julia, this is a ‘built-in’ feature: as long as you define your code precisely, it <em>will</em> accept only the right kind of data and raise an error for any other call. I call this a win-win!</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> add_integers_badly(x, y)
        x = int(x)
        y = int(y)
        x + y
    <span class="kw">end</span></code></pre>
<p>The function above is problematic because it says one thing and does another. On its face, it accepts all kinds of values. In reality, however, not only is the function meant to only work with numeric types (since <code>x + y</code> has a very specific meaning for other types), it is in fact meant to enforce a particular type (<code>Int</code> types) by using a type conversion command (<code>int()</code>). If so, it would be easier to simply limit the function to accepting the right kind of input type. Not only would this prevent the overhead penalty of converting data types, it would provide for type-stable and performant code that tells readers (and automated documentation generators) what the function takes in.</p>
<h3 id="time-your-functions-time-your-changes">Time your functions, time your changes</h3>
<p>Julia includes a very convenient macro, <code>@time</code>, that helps you keep track of the time and memory allocation of your functions. It pays to check the execution time of your functions, in particular when you have made changes that you think will affect performance. It’s easiest to use the REPL or IJulia to time functions. Define your function first, then invoke it following the macro <code>@time</code>. In the following, we will define a Fibonacci function <code>fib(n) = n &lt; 2 ? n : fib(n - 1) + fib(n - 2)</code>, and look at its speed in detecting the 32nd Fibonacci number:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; @time fib(<span class="fl">32</span>)
    elapsed time: <span class="fl">0.028219738</span> seconds (<span class="fl">33112</span> bytes allocated)
    <span class="fl">2178309</span></code></pre>
<p>You can also use <code>@elapsed</code>, <code>@time</code>’s younger sibling, which returns only the elapsed seconds:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; @elapsed fib(<span class="fl">32</span>)
    <span class="fl">0.028076393</span></code></pre>
<p>However, <code>@time</code> is vastly superior. Runaway memory is the first sign that something is not going well with your application.</p>
<h3 id="write-short-concise-functions">Write short, concise functions</h3>
<p>The core ideology, and key success factor, of *NIX systems was to conceive of a complex system as a sum of small applications that did one thing, and did it well. Many, such as <code>grep</code>, have been in use for decades with much success. The same idea applies for Julia. Not only will it make your code better (it’s easier to forget something in the middle of a big, complicated function), it will also make your code faster. This is because Julia’s compiler can benefit from type-specialising code at function boundaries. Julia’s own documentation has a great documentation of this feature:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> strange_twos(n)
        a = <span class="dt">Array</span>(randbool() ? <span class="dt">Int64</span> : <span class="dt">Float64</span>, n)
        <span class="kw">for</span> i = <span class="fl">1</span>:n
            a[i] = <span class="fl">2</span>
        <span class="kw">end</span>
        <span class="kw">return</span> a
    <span class="kw">end</span></code></pre>
<p>When Julia’s compiler is handed this code, it does not know at the time of executing the loop what the value of <code>a</code> is - only that it can be one of <code>Array{Int64}</code> or <code>Array{Float64}</code>. As such, it will have to provide for both outcomes. A better pair of functions would separate the inner and outer loops:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> fill_twos!(a)
        <span class="kw">for</span> i=<span class="fl">1</span>:length(a)
            a[i] = <span class="fl">2</span>
        <span class="kw">end</span>
    <span class="kw">end</span>
    
    <span class="kw">function</span> strange_twos(n)
        a = <span class="dt">Array</span>(randbool() ? <span class="dt">Int64</span> : <span class="dt">Float64</span>, n)
        fill_twos!(a)
        <span class="kw">return</span> a
    <span class="kw">end</span></code></pre>
<p>The result is that when calling <code>strange_twos(n)</code>, Julia’s interpreter will know whether to compile <code>fill_twos()</code> for <code>Int64</code> or <code>Float64</code>. This will yield a performance benefit:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; @time strange_twos(<span class="fl">16</span>)
    elapsed time: <span class="fl">0.000767759</span> seconds (<span class="fl">7120</span> bytes allocated)
    
    julia&gt; @time fast_strange_twos(<span class="fl">16</span>)
    elapsed time: <span class="fl">0.009221679</span> seconds (<span class="fl">179592</span> bytes allocated)</code></pre>
<p>Wait a second! That’s actually 12 times slower! What happened? Let’s see if it’s just an accident.</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; @time fast_strange_twos(<span class="fl">16</span>)
    elapsed time: <span class="fl">9.286e-6</span> seconds (<span class="fl">256</span> bytes allocated)</code></pre>
<p>That looks much closer to what we expected. The reason is that when we called <code>fast_strange_twos()</code> the first time, the time included the JIT compiler’s copmilation time. The lesson is to run every function once before testing the time it takes, and where multiple functions can result in multiple types, we might need to understand that unless the JIT compiler has encountered each type, there might be anomalous results. At second execution, we were lucky - the random number generator had the program retrieve the same type of number to fill the array. Then we ran it again:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; @time fast_strange_twos(<span class="fl">16</span>)
    elapsed time: <span class="fl">0.002645026</span> seconds (<span class="fl">6600</span> bytes allocated)</code></pre>
<p>This time, the numbers to fill the array were different. As a result, it took a little longer. However, from this point on, until I close down the REPL, the <code>fast_strange_twos()</code> function will evaluate at the same time and at the same memory cost.</p>
<h3 id="danger-zone">Danger zone</h3>
<p>Julia allows you something called <em>performance annotations</em>, one of which is <code>@inbounds</code>. This speeds up array processing by circumventing bounds checking. Thus, for instance, a function to calculate the dot product of two arrays, might make use of this function:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> dotproduct(x::<span class="dt">Array</span>, y::<span class="dt">Array</span>)
        result = zero(eltype(x))
        <span class="kw">for</span> i = <span class="fl">1</span>:length(x)
            @inbounds result += x[i] * y[i]
        <span class="kw">end</span>
        <span class="kw">return</span> result
    <span class="kw">end</span></code></pre>
<p>In this case, <code>@inbounds</code> is safe because we know that due to the way <code>i</code> is defined (<code>1:length(x)</code>), there will never be an <code>i</code> that exceeds the length of <code>x</code> that would result in an out-of-bounds subscript. As such, bounds checking is more or less superfluous. To see the effect this has on execution time, let’s compare it with the same function without the bounds checking disabled, called <code>slow_dotproduct</code>:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; @time(dotproduct([<span class="fl">1234</span>, <span class="fl">5747</span>, <span class="fl">2243243</span>, <span class="fl">535345</span>, <span class="fl">76345</span>, <span class="fl">2346</span>], [<span class="fl">23468</span>, <span class="fl">4563</span>, <span class="fl">2457</span>, <span class="fl">124556</span>, <span class="fl">27563</span>, <span class="fl">63456</span>]))
    elapsed time: <span class="fl">1.4494e-5</span> seconds (<span class="fl">288</span> bytes allocated)
    <span class="fl">74500427955</span>
    
    julia&gt; @time(slow_dotproduct([<span class="fl">1234</span>, <span class="fl">5747</span>, <span class="fl">2243243</span>, <span class="fl">535345</span>, <span class="fl">76345</span>, <span class="fl">2346</span>], [<span class="fl">23468</span>, <span class="fl">4563</span>, <span class="fl">2457</span>, <span class="fl">124556</span>, <span class="fl">27563</span>, <span class="fl">63456</span>]))
    elapsed time: <span class="fl">0.004523183</span> seconds (<span class="fl">105816</span> bytes allocated)
    <span class="fl">74500427955</span></code></pre>
<p>Not only did the bounds-checking dot product require over 350 times the allocated memory of our non-bounds-checking product, but it also took over 300 times the execution time of the faster process. This might be inperceptible, since even the slower function took only 4.5ms to execute, but at a scale, these differences extrapolate to massive performance gains through good but circumspect programming. Just be sure you eliminate bounds checking only where you have a good reason to assume you will not need it because your own script provides for it.</p>
<h2 id="type-stable-code">Type-stable code</h2>
<p><em>Type-stable</em> is functional programmer speak for code in which variables don’t change their type. The reason why this is important is that type conversion represents an overhead that, at scale, slows down the process dramatically. Consider the following example:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> badly_written(n::<span class="dt">Integer</span>)
        result = <span class="fl">0</span>
        <span class="kw">for</span> i <span class="kw">in</span> <span class="fl">1</span>:n
            result += cos(rand())
        <span class="kw">end</span>
        <span class="kw">return</span> result
    <span class="kw">end</span></code></pre>
<p>This function adds the cosine of a pseudorandom number (<code>rand()</code> generates a pseudorandom number using Julia’s Mersenne twister implementation) to a result variable that is initialised as zero, which will be interpreted by Julia as an <code>Int64</code>. What we do know about cosines, however, is that they generally do not tend to yield integers, and indeed what we do know about Julia is that the cosine function will yield even results expressible as integers as floating-point results (try <code>cos(2π)</code>). Therefore, we know that before it can do anything, Julia will need to convert <code>result</code>, an <code>Int64</code>, to a <code>Float</code> type it can add another <code>Float</code> to. This, effectively, is wasted time.</p>
<p>A better function, thus, would be</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    <span class="kw">function</span> well_written(n::<span class="dt">Integer</span>)
        result = <span class="fl">0.0</span>
        <span class="kw">for</span> i <span class="kw">in</span> <span class="fl">1</span>:n
            result += cos(rand())
        <span class="kw">end</span>
        <span class="kw">return</span> result
    <span class="kw">end</span></code></pre>
<p>Just how significant is the performance difference? After doing a dry run of running each function once, which allows the JIT compiler to compile the function so that we avoid the issues we discussed above, we get the following:</p>
<pre class="sourceCode julia"><code class="sourceCode julia">    julia&gt; @time badly_written(<span class="fl">100000</span>)
    elapsed time: <span class="fl">0.006668156</span> seconds (<span class="fl">3200048</span> bytes allocated)
    
    julia&gt; @time well_written(<span class="fl">100000</span>)
    elapsed time: <span class="fl">0.001911581</span> seconds (<span class="fl">64</span> bytes allocated)</code></pre>
<p>Not only did type conversion (just once!) make our code about 3.5 times slower, it also made it consume 50,000 (!) times the memory. Type stability makes for faster and more performant code.</p>
<h2 id="legible-code">Legible code</h2>
<p>Julia is a <em>high-level language</em>, meaning that it is closer to natural languages than low-level languages are. In fact, it could, like Python, be described as ‘executable pseudocode’, with a minimum of syntax, eschewing unnecessary braces and parentheses and instead using a clear, legible indented structure. However, it’s not difficult to write illegible code in Julia – indeed, the Stack Exchange <a href="http://codegolf.stackexchange.com/">Code Golf</a> board, where users specialise in cramming their solution into the shortest possible sequence, has quite a lot of it. Unless you’re code golfing, your code should be beautiful and legible.</p>
<p>Unfortunately, legible means different things to different people, and that’s how style guides came to be. Julia, being a young language, does not have as many and as thoroughly debated style guides as, say, Python’s <code>PEP8</code> or various Javascript style guides. The following seeks to point out a few of the most salient points of writing idiomatic Julia, as observed from core packages and prominent Julia packages, as well as the <a href="http://julia.readthedocs.org/en/latest/manual/style-guide/">official Style Guide</a> and John Myles White’s <a href="https://github.com/johnmyleswhite/Style.jl">Style.jl</a>. Both are definitely worth reading - the former is more a high-level overview while the latter is very specific. However, coding is a matter of judgment and as a programmer, one of the things you are paid for is your sense of judgment, both in resolving the occasional inconsistencies within and among style guides by balancing countervailing objectives and in deciding whether to follow particular rules. Sure, the style guide says to stick to 80 characters a line, but should I break an 81 character line? The conventions suggest to eschew <code>lowercase_separated_names</code> and <code>CamelCase</code>, but what if the name is too long and cannot be sensibly abbreviated (a problem people encounter in the educational context quite often, as the author did while writing this book and trying to balance adherence to writing more understandable code)?</p>
<h1 id="next-steps">Next steps</h1>
</body>
</html>
